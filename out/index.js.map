{"version":3,"file":"index.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAoC;AACZ;AACJ;AACuB;AAC3C;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,oDAAa;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oDAAa;AAC9C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,QAAQ,oDAAa,iBAAiB,2EAA2E;AACjJ;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oDAAa;AAC9C;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oDAAa;AAClD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAY,iBAAiB,KAAK,GAAG,UAAU;AAClE,IAAI,wDAAgB,QAAQ,6BAA6B;AACzD;AACA;AACA;AACA,yBAAyB,oDAAa;AACtC,wBAAwB,uDAAgB,8BAA8B;AACtE,uCAAuC,KAAK,GAAG,WAAW;AAC1D,sBAAsB;AACtB,wBAAwB,oDAAa;AACrC,wBAAwB,uDAAgB,8BAA8B;AACtE,uCAAuC,KAAK,GAAG,WAAW;AAC1D;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd,gEAAgE,IAAI;AACpE;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrKkF;AACnC;AACf;AAChC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAgB,yBAAyB,4DAA4D,qDAAgB,uBAAuB;AAClK;AACA,8BAA8B,0DAAmB;AACjD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,4DAA4D,MAAM;AAClE;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,sCAAsC,0BAA0B,IAAI,QAAQ,kKAAkK,IAAI,cAAc;AAChQ;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sBAAsB,IAAI,eAAe,IAAI,cAAc;AAChG;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD,uBAAuB;AACvB;AACA,8BAA8B,SAAS,4BAA4B,IAAI,YAAY,4BAA4B;AAC/G;AACA,0BAA0B,aAAa;AACvC;AACA;AACA,6CAA6C,eAAe,GAAG;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F;AAC9F,kGAAkG;AAClG;AACA,6DAA6D;AAC7D;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW;AACxC,6BAA6B,iBAAiB;AAC9C,6BAA6B,eAAe;AAC5C;AACA;AACA,wDAAwD,WAAW,IAAI,QAAQ,mCAAmC,IAAI,cAAc;AACpI;AACA,wDAAwD,UAAU,aAAa,QAAQ;AACvF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa,IAAI,cAAc;AAC/B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS,aAAa,SAAS,gBAAgB,WAAW,GAAG;AACrH;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,QAAQ,WAAW;AACnF;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,gDAAgD,iCAAiC,QAAQ;AACzF;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iDAAiD,QAAQ,WAAW,IAAI,cAAc;AACtF,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY,WAAW,WAAW,kBAAkB,SAAS,eAAe;AACrH;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI,cAAc,oFAAoF,SAAS,gBAAgB;AAC9K;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,qDAAqD,mBAAmB,+BAA+B,eAAe,YAAY;AAClI,sDAAsD,mBAAmB,iCAAiC;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB,IAAI,cAAc,oFAAoF;AAC1K;AACA;AACA;AACA;AACA,iDAAiD,SAAS,aAAa;AACvE;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI,cAAc,gDAAgD;AAClH;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI,QAAQ,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,iDAAiD,IAAI,QAAQ,WAAW,IAAI,cAAc;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,QAAQ,WAAW,IAAI,uBAAuB;AACrH;AACA;AACA;AACA;AACA;AACA,+CAA+C,qBAAqB,IAAI,QAAQ,WAAW,IAAI,cAAc;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,IAAI,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,IAAI,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI,QAAQ,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB,gBAAgB;AACnD,kBAAkB,iBAAiB;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uDAAuD,eAAe,UAAU;AAChF;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA,6EAA6E,uBAAuB;AACpG;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY,aAAa;AAC3C;AACA;AACA,0BAA0B,SAAS,mBAAmB;AACtD,0BAA0B,YAAY;AACtC;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA,iBAAiB;AACjB;AACA,6BAA6B,QAAQ;AACrC,iBAAiB;AACjB;AACA,gCAAgC,QAAQ;AACxC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA,8EAA8E,UAAU,IAAI,cAAc,YAAY;AACtH;AACA;AACA,0FAA0F,kCAAkC,IAAI,cAAc,YAAY;AAC1J,mDAAmD,4DAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,kCAAkC,IAAI,mBAAmB,IAAI,cAAc;AAC7I;AACA;AACA,aAAa;AACb;AACA,+EAA+E,QAAQ,UAAU,kBAAkB,IAAI,yBAAyB,IAAI,qBAAqB,kBAAkB,GAAG;AAC9L;AACA,0EAA0E,+BAA+B,IAAI,cAAc,YAAY,OAAO;AAC9I,0DAA0D,+BAA+B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,eAAe,IAAI,YAAY,IAAI,cAAc;AACnG;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qDAAqD,IAAI,cAAc,oBAAoB;AAC3F;AACA;AACA;AACA;AACA,4BAA4B,SAAS,mCAAmC;AACxE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACptBa;AACe;AAC5B,oDAAa;AACb;AAC8B;AACJ;AACc;AACkB,CAAC;AACd;AASlB;AACU;AACa;AACT;AACQ;AAC7B;AACuB;AACe;AACZ;AACmB;AAC5B;AACrC;AACA,sBAAsB;AACtB;AACA;AACA,CAAC;AACD;AACA,QAAQ,sDAAc;AACtB,QAAQ,+DAAa;AACrB,CAAC;AACD;AACA,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,8CAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAgB;AAChB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,eAAe,sDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,qCAAqC,MAAM,uBAAuB,mCAAmC;AACrG;AACA,4DAA4D,mBAAmB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B,QAAQ,wDAAgB,IAAI,UAAU;AACtC;AACA;AACA;AACA;AACA,+CAA+C,QAAQ,UAAU,sHAAsH;AACvL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,mEAAoB;AACtB;AACA;AACA,eAAe,sDAAc;AAC7B;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA,YAAY,wDAAgB,IAAI,UAAU;AAC1C,YAAY,6CAAK;AACjB,YAAY,wDAAgB,IAAI,UAAU;AAC1C,YAAY,6CAAK;AACjB;AACA,cAAc,wDAAgB,IAAI,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAgB,IAAI,0BAA0B;AACxD,GAAG;AACH;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA,QAAQ;AACR,MAAM;AACN;AACA,EAAE,mEAAoB;AACtB;AACA,oBAAoB,uBAAuB;AAC3C;AACA,YAAY,wDAAgB,IAAI,UAAU;AAC1C,YAAY,6CAAK;AACjB;AACA,GAAG;AACH;AACA,EAAE,mEAAoB;AACtB;AACA,oBAAoB,uBAAuB;AAC3C;AACA,YAAY,wDAAgB,IAAI,UAAU;AAC1C,YAAY,6CAAK;AACjB;AACA;AACA,GAAG;AACH;AACA,EAAE,mEAAoB;AACtB,eAAe,sDAAc;AAC7B;AACA,YAAY,6CAAK;AACjB,YAAY,wDAAgB,IAAI,UAAU;AAC1C,mCAAmC,UAAU;AAC7C,YAAY,wDAAgB,IAAI,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc,wDAAgB,IAAI,UAAU;AAC5C,OAAO;AACP,YAAY,6CAAK;AACjB;AACA;AACA,UAAU,wDAAgB,IAAI,UAAU,QAAQ,mDAAmD;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAgB,mDAAmD,gBAAgB;AAC5G,0BAA0B,wDAAgB,qDAAqD,gBAAgB;AAC/G,MAAM;AACN,kCAAkC,kDAAU;AAC5C;AACA;AACA,GAAG;AACH,EAAE;AACF,8BAA8B,kDAAU;AACxC;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,UAAU;AACxC;AACA,YAAY,wDAAgB,IAAI,UAAU;AAC1C,KAAK;AACL,UAAU,6CAAK;AACf;AACA;AACA;AACA;AACA,QAAQ,uDAAe;AACvB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,mBAAmB,sDAAc;AACjC;AACA;AACA;AACA;AACA,sBAAsB,8DAAY;AAClC,yBAAyB,2DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAgB,mCAAmC,aAAa,KAAK,YAAY;AAC5G;AACA;AACA,sCAAsC,qOAAqO;AAC3Q;AACA,YAAY,8DAAY;AACxB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA,QAAQ,sDAAc;AACtB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,aAAa,sDAAc;AAC3B;AACA,QAAQ,wDAAgB,IAAI,UAAU,uBAAuB,+CAA+C,GAAG,UAAU,GAAG,gBAAgB,KAAK,0BAA0B,iBAAiB,YAAY;AACxM,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA;AACA,+EAA+E,iBAAiB;AAChG;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA;AACA;AACA,+EAA+E,iBAAiB;AAChG;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,UAAU;AACxC,UAAU,6CAAK;AACf;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,wBAAwB,wDAAgB,IAAI,UAAU;AACtD;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,UAAU;AACxC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B,sCAAsC,iBAAiB;AACvD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B,yCAAyC,iBAAiB;AAC1D;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B,yCAAyC,iBAAiB,IAAI,2BAA2B;AACzF;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY,aAAa,OAAO,GAAG,iBAAiB,MAAM,OAAO;AAClF;AACA,QAAQ,wDAAgB;AACxB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY,aAAa,OAAO,GAAG,iBAAiB,MAAM,OAAO;AAClF;AACA,QAAQ,wDAAgB;AACxB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B,yCAAyC,QAAQ,IAAI,2BAA2B;AAChF;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,UAAU;AACxC,UAAU,6CAAK;AACf;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,UAAU;AACxC,UAAU,6CAAK;AACf;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,gBAAgB;AAC9C,UAAU,6CAAK;AACf;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,oBAAoB,aAAa;AACjC,GAAG;AACH;AACA;AACA,mBAAmB,uBAAuB,EAAE,SAAS;AACrD;AACA,UAAU,6CAAK;AACf,UAAU,wDAAgB;AAC1B;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa,4DAA4D;AACzE,CAAC;AACD;AACA;AACA,aAAa,sDAAc;AAC3B;AACA,+CAA+C;AAC/C;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA,CAAC;AACD;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,UAAU,kBAAkB,qBAAqB;AAC/E,UAAU,wDAAgB,IAAI,UAAU;AACxC,UAAU,6CAAK;AACf;AACA,aAAa,sDAAc;AAC3B;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,UAAU,iBAAiB,qBAAqB;AAC9E,UAAU,6CAAK;AACf;AACA,aAAa,sDAAc;AAC3B;AACA,+CAA+C,qBAAqB;AACpE,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,UAAU;AACxC,UAAU,6CAAK;AACf;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA,YAAY,wDAAgB,IAAI,UAAU;AAC1C,YAAY,6CAAK;AACjB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA,YAAY,wDAAgB,IAAI,UAAU,aAAa,sBAAsB;AAC7E,YAAY,6CAAK;AACjB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,UAAU,kBAAkB,IAAI;AAC9D,UAAU,6CAAK;AACf;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,uFAAuF,UAAU;AACjG;AACA,MAAM;AACN;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA,gBAAgB,6CAAK;AACrB,UAAU;AACV,sCAAsC,kDAAU;AAChD;AACA,cAAc,6CAAK;AACnB;AACA;AACA,IAAI;AACJ,gCAAgC,kDAAU;AAC1C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,UAAU;AACxC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA,aAAa,qCAAqC;AAClD,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,UAAU;AACxC;AACA,CAAC;AACD;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA,kBAAkB,uBAAuB;AACzC;AACA,qBAAqB,iBAAiB,KAAK,+DAA+D;AAC1G;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA,qBAAqB,WAAW,KAAK,4DAA4D;AACjG;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA,YAAY,wDAAgB,IAAI,UAAU;AAC1C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA,YAAY,wDAAgB,IAAI,UAAU;AAC1C,YAAY,6CAAK;AACjB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA,YAAY,wDAAgB,IAAI,UAAU;AAC1C,YAAY,6CAAK;AACjB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa,sDAAc;AAC3B,kCAAkC,gBAAgB;AAClD;AACA,6DAA6D,cAAc,mBAAmB,+CAA+C,YAAY,MAAM,aAAa;AAC5K;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA,+BAA+B,0BAA0B,UAAU,OAAO;AAC1E;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc,mBAAmB,8DAA8D,WAAW;AACpK,IAAI;AACJ,0DAA0D,cAAc,mBAAmB;AAC3F;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,2DAAS;AAChB;AACA,sBAAsB,8DAAY;AAClC;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B,kCAAkC,gBAAgB;AAClD;AACA,SAAS,2DAAS;AAClB;AACA,wBAAwB,8DAAY;AACpC;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,UAAU,wDAAgB,IAAI,uBAAuB,QAAQ,4BAA4B,KAAK;AAC9F,IAAI;AACJ,gBAAgB,kDAAU;AAC1B;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,eAAe,sDAAc;AAC7B,oCAAoC,gBAAgB;AACpD,SAAS,2DAAS;AAClB;AACA,wBAAwB,8DAAY;AACpC;AACA,6BAA6B,2DAAS;AACtC;AACA;AACA;AACA;AACA;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B,8DAAY;AACpC,2BAA2B,2DAAS;AACpC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ,gCAAgC,kDAAU;AAC1C;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa,sDAAc;AAC3B,kCAAkC,gBAAgB;AAClD,OAAO,2DAAS;AAChB,sBAAsB,8DAAY;AAClC,yBAAyB,2DAAS;AAClC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAQ;AACjC,IAAI;AACJ,gBAAgB,kDAAU;AAC1B;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa,sDAAc;AAC3B,kCAAkC,gBAAgB;AAClD,OAAO,2DAAS;AAChB,sBAAsB,8DAAY;AAClC,yBAAyB,2DAAS;AAClC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa,sDAAc;AAC3B,kCAAkC,gBAAgB;AAClD,OAAO,2DAAS;AAChB,sBAAsB,8DAAY;AAClC,yBAAyB,2DAAS;AAClC;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA,SAAS,2DAAS;AAClB,wBAAwB,8DAAY;AACpC;AACA,mBAAmB,aAAa;AAChC,QAAQ;AACR,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD,QAAQ,+DAAa;AACrB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,UAAU,wDAAgB,IAAI,UAAU;AACxC,UAAU,6CAAK;AACf;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAgB,IAAI,SAAS,gBAAgB,IAAI,KAAK,eAAe;AACjF;AACA,IAAI;AACJ,gCAAgC,kDAAU;AAC1C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,YAAY,wDAAgB,IAAI,SAAS,SAAS,eAAe;AACjE;AACA,IAAI;AACJ,gCAAgC,kDAAU;AAC1C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAgB,IAAI,IAAI,iBAAiB,gBAAgB;AAC3F;AACA,gDAAgD,uEAAuE;AACvH;AACA,UAAU;AACV,gDAAgD,IAAI;AACpD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,4CAA4C,uEAAuE;AACnH;AACA;AACA,MAAM;AACN,qFAAqF,UAAU;AAC/F;AACA,IAAI;AACJ,gCAAgC,kDAAU;AAC1C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,gBAAgB,kDAAU;AAC1B;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,+BAA+B,qEAAqE;AACpG,aAAa,uEAAuE;AACpF,CAAC;AACD;AACA;AACA;AACA;AACA,qDAAqD;AACrD,mBAAmB;AACnB,+BAA+B,iDAAiD;AAChF,aAAa,iEAAiE;AAC9E,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA,eAAe,mDAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,2DAAmB;AACrB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU,8BAA8B,UAAU,IAAI,OAAO;AAC9F,yCAAyC,UAAU,IAAI,OAAO;AAC9D;AACA,wBAAwB;AACxB;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA,2BAA2B,wDAAgB;AAC3C;AACA;AACA;AACA,oDAAoD,SAAS,cAAc,OAAO,KAAK,eAAe;AACtG;AACA,iDAAiD,UAAU,IAAI,OAAO;AACtE;AACA;AACA,0DAA0D,SAAS,cAAc,OAAO,KAAK,eAAe;AAC5G;AACA,+CAA+C,SAAS,cAAc,OAAO,6EAA6E,eAAe;AACzK,oBAAoB;AACpB,mBAAmB;AACnB;AACA;AACA,gBAAgB;AAChB,eAAe;AACf,4DAA4D,UAAU,IAAI,OAAO;AACjF;AACA,aAAa;AACb;AACA;AACA;AACA,UAAU;AACV,MAAM;AACN;AACA;AACA,IAAI;AACJ,gCAAgC,kDAAU;AAC1C;AACA,CAAC;AACD;AACA,sBAAsB,sDAAW,QAAQ,wDAAS,MAAM,qEAAc;AACtE,mBAAmB,6DAAe;AAClC;AACA;AACA;AACA;AACA,iBAAiB,2DAAa;AAC9B,EAAE,wDAAgB;AAClB,2DAAa;AACb;AACA;AACA;AACA,2DAA2D,KAAK;AAChE,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ,gBAAgB,gBAAgB;AAClG;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qDAAqD,UAAU,QAAQ,mCAAmC,mBAAmB,iBAAiB;AAC9I;AACA,6EAA6E,QAAQ,iBAAi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AAgB;AAClG;AACA;AACA;AACA,qBAAqB;AACrB;AACA,gDAAgD,YAAY,SAAS,mCAAmC,wBAAwB,mBAAmB;AACnJ;AACA,sEAAsE,UAAU,iBAAiB,gBAAgB;AACjH;AACA,kDAAkD,WAAW,UAAU,2CAA2C,qBAAqB,0BAA0B;AACjK,uBAAuB;AACvB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA,qCAAqC,WAAW,UAAU,WAAW,cAAc,gBAAgB;AACnG,qCAAqC,MAAM,KAAK,gBAAgB;AAChE;AACA;AACA,6BAA6B,wDAAgB,IAAI,KAAK,gBAAgB,gBAAgB;AACtF;AACA;AACA;AACA,cAAc;AACd;AACA,oBAAoB,wDAAgB,IAAI,UAAU,SAAS,mCAAmC,uBAAuB,kBAAkB;AACvI;AACA,0CAA0C,wDAAgB,IAAI,IAAI,eAAe,WAAW,KAAK,gBAAgB;AACjH;AACA,sBAAsB,wDAAgB,IAAI,UAAU,SAAS,0CAA0C,oBAAoB,yBAAyB;AACpJ,gBAAgB;AAChB,4BAA4B,kDAAU;AACtC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,eAAe,2BAA2B,IAAI,iBAAiB,EAAE,4BAA4B,0EAA0E,OAAO;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAc;AAC3B;AACA;AACA,eAAe,2BAA2B,OAAO,gBAAgB,MAAM,4BAA4B,0EAA0E,OAAO;AACpL;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAc;AACjC;AACA;AACA;AACA,YAAY,0FAA0F;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM;AACpD;AACA;AACA;AACA;AACA,8DAA8D,MAAM;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB,OAAO,2BAA2B,SAAS,eAAe;AACjG;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB,OAAO,qBAAqB,QAAQ,uBAAuB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,4BAA4B,IAAI,MAAM;AACtC,6BAA6B,IAAI,OAAO;AACxC;AACA,gCAAgC;AAChC,6BAA6B,KAAK,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAgB,IAAI,UAAU,gBAAgB,iBAAiB;AACpF,UAAU,wDAAgB,IAAI,YAAY,gCAAgC,eAAe,IAAI,2BAA2B;AACxH;AACA,YAAY,wDAAgB,IAAI,UAAU,kCAAkC,eAAe;AAC3F;AACA,iBAAiB,sDAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAgB,IAAI,UAAU,uBAAuB,SAAS;AAC1E,kBAAkB,6CAAK;AACvB;AACA,UAAU;AACV,sCAAsC,kDAAU;AAChD;AACA;AACA;AACA,IAAI;AACJ,gBAAgB,kDAAU;AAC1B;AACA;;;;;;;;;;;;;;;;;;;;;;;ACtkEwB;AACxB;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iBAAiB,6CAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AAC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CT;AACxB;AACuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D,UAAU;AACV,wBAAwB,kDAAU;AAClC,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN,iBAAiB;AACjB;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,4DAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAc;AAC5C;AACA,aAAa;AACb;AACA;AACA,qEAAqE,cAAc;AACnF,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA,iBAAiB;AACjB;AACA,0BAA0B;AAC1B,2BAA2B;AAC3B;AACA,+DAA+D,gCAAgC,MAAM,gEAAU;AAC/G,wDAAwD,YAAY;AACpE,+DAA+D,UAAU;AACzE;AACA;AACA,6BAA6B;AAC7B,UAAU;AACV,wBAAwB,kDAAU;AAClC;AACA;AACA;AACA;AACA;AACA,+DAA+D,wBAAwB;AACvF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,YAAY,GAAG;AAC1F;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mCAAmC;AACpD;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB,gCAAgC,kDAAU;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAc;AACjC;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA,wBAAwB,yCAAG;AAC3B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,4BAA4B,oFAAoF;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,wCAAwC,kDAAU;AAClD;AACA;AACA,sBAAsB;AACtB,8DAA8D,kDAAkD,QAAQ,GAAG;AAC3H,wDAAwD,kDAAkD,QAAQ,GAAG;AACrH;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA,0DAA0D,kDAAkD,QAAQ,GAAG;AACvH,oDAAoD,kDAAkD,QAAQ,GAAG;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yCAAG,6BAA6B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,uCAAuC,yCAAG,8BAA8B,iBAAiB;AACzF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oDAAoD,yCAAG,6BAA6B;AACpF;AACA;AACA;AACA;AACA,0DAA0D,yCAAG;AAC7D;AACA;AACA;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA,YAAY,6CAAK;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAG;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,oDAAoD,yCAAG,6BAA6B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAG;AACvB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wBAAwB,yCAAG;AAC3B;AACA,qBAAqB;AACrB;AACA;AACA,UAAU;AACV,wBAAwB,kDAAU;AAClC;AACA;AACA;AACA;AACA,QAAQ,0DAAa;AACrB;AACA,4BAA4B,wDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wDAAW;AAC3D;AACA,uDAAuD,oDAAO;AAC9D;AACA;AACA,wCAAwC,+DAAkB;AAC1D;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,oCAAoC,+DAAkB;AACtD;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB,+CAA+C,YAAY,kDAAU,MAAM;AAC3E,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAG;AACvB,6BAA6B,yCAAG,4BAA4B;AAC5D;AACA,4BAA4B,yCAAG;AAC/B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB,yCAAG;AACvB,6BAA6B,yCAAG,+BAA+B;AAC/D;AACA,4BAA4B,yCAAG;AAC/B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oBAAoB,yCAAG;AACvB,6BAA6B,yCAAG,8BAA8B;AAC9D;AACA,4BAA4B,yCAAG;AAC/B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oBAAoB,yCAAG;AACvB,6BAA6B,yCAAG,kCAAkC;AAClE;AACA,4BAA4B,yCAAG;AAC/B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB,yCAAG;AACvB,6BAA6B,yCAAG,wBAAwB;AACxD;AACA,4BAA4B,yCAAG;AAC/B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wBAAwB,kDAAU;AAClC;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAG;AACvB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,UAAU;AACV,wBAAwB,kDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yCAAG,0BAA0B,UAAU;AAChG;AACA,cAAc;AACd,4BAA4B,kDAAU;AACtC;AACA,UAAU;AACV;AACA;AACA;AACA,4BAA4B,yCAAG,yBAAyB,UAAU;AAClE;AACA;AACA;AACA,iEAAiE,yCAAG,0BAA0B,UAAU;AACxG,iDAAiD,SAAS;AAC1D;AACA;AACA,sBAAsB;AACtB;AACA;AACA,8BAA8B,6CAAK;AACnC;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAAU;AACpC;AACA,oBAAoB,kDAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yCAAyC,yCAAG;AAC5C;AACA,aAAa;AACb;AACA,UAAU;AACV,wBAAwB,kDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAG;AACvB,6BAA6B,yCAAG,4BAA4B;AAC5D;AACA,4BAA4B,yCAAG;AAC/B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB,yCAAG;AACvB,6BAA6B,yCAAG,+BAA+B;AAC/D;AACA,4BAA4B,yCAAG;AAC/B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oBAAoB,yCAAG;AACvB,6BAA6B,yCAAG,8BAA8B;AAC9D;AACA,4BAA4B,yCAAG;AAC/B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oBAAoB,yCAAG;AACvB,6BAA6B,yCAAG,kCAAkC;AAClE;AACA,4BAA4B,yCAAG;AAC/B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB,yCAAG;AACvB,6BAA6B,yCAAG,wBAAwB;AACxD;AACA,4BAA4B,yCAAG;AAC/B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,kDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gDAAS,2CAA2C,KAAK,SAAS,iBAAiB;AAClI;AACA,sBAAsB;AACtB,oCAAoC,kDAAU;AAC9C;AACA;AACA;AACA;AACA,+DAA+D,0BAA0B;AACzF;AACA;AACA;AACA;AACA,gBAAgB,iDAAU;AAC1B;AACA,qBAAqB;AACrB;AACA,oCAAoC,kDAAU;AAC9C,oCAAoC,kDAAU;AAC9C;AACA,qBAAqB;AACrB,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC7lB2B;AAC3B;AACA;AACO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,qCAAqC,MAAM,uBAAuB,mCAAmC;AACrG;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY,QAAQ,UAAU,EAAE,yBAAyB;AAC1E;AACA,iBAAiB;AACjB;AACA;AACA;AACO,sDAAsD;AAC7D;AACA,iBAAiB,wDAAiB;AAClC;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA,cAAc,gDAAS,IAAI,UAAU,QAAQ,gCAAgC,SAAS,GAAG;AACzF;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,6BAA6B,4CAAK;AAClC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN,UAAU,qDAAc;AACxB;AACA,QAAQ;AACR,qCAAqC,UAAU,QAAQ,kCAAkC;AACzF;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,QAAQ;AACR,6BAA6B,gBAAgB,qBAAqB,SAAS;AAC3E;AACA,gBAAgB,gDAAS,IAAI,UAAU,QAAQ,sCAAsC,SAAS,IAAI,eAAe,GAAG,eAAe,IAAI,0BAA0B,GAAG;AACpK,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB;AACpB;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA,yBAAyB,4CAAK,GAAG,oEAAoE;AACrG;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClLA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;WACD;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA,sGAAsG;WACtG;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA,EAAE;WACF;WACA;;;;;WChEA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":[".././cloudinary.js",".././dbservice.js",".././index.js",".././mailreader.js",".././nest/app.module.ts",".././nest/components/user-data/dto/create-user-data.dto.ts",".././nest/components/user-data/schemas/user-data.schema.ts",".././nest/components/user-data/user-data.controller.ts",".././nest/components/user-data/user-data.module.ts",".././nest/components/user-data/user-data.service.ts",".././nest/components/users/schemas/user.schema.ts",".././nest/components/users/users.controller.ts",".././nest/components/users/users.module.ts",".././nest/components/users/users.service.ts",".././telegramManager.js",".././utils.js","../external commonjs \"@nestjs/common\"","../external commonjs \"@nestjs/core\"","../external commonjs \"@nestjs/mongoose\"","../external commonjs \"@nestjs/platform-express\"","../external commonjs \"@nestjs/swagger\"","../external commonjs \"axios\"","../external commonjs \"body-parser\"","../external commonjs \"cloudinary\"","../external commonjs \"cors\"","../external commonjs \"dotenv\"","../external commonjs \"express\"","../external commonjs \"imap\"","../external commonjs \"mongodb\"","../external commonjs \"mongoose\"","../external commonjs \"node-schedule-tz\"","../external commonjs \"telegram\"","../external commonjs \"telegram/client/uploads\"","../external commonjs \"telegram/events/index.js\"","../external commonjs \"telegram/sessions\"","../external node-commonjs \"child_process\"","../external node-commonjs \"fs\"","../external node-commonjs \"path\"","../webpack/bootstrap","../webpack/runtime/async module","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/before-startup","../webpack/startup","../webpack/after-startup"],"sourcesContent":["import cloudinary from 'cloudinary';\r\nimport path from 'path';\r\nimport fs from 'fs';\r\nimport { fetchWithTimeout } from './utils';\r\n\r\nexport class CloudinaryService {\r\n    static instance;\r\n    resources = new Map();\r\n\r\n    constructor() {\r\n        cloudinary.v2.config({\r\n            cloud_name: process.env.CL_NAME,\r\n            api_key: process.env.CL_APIKEY,\r\n            api_secret: process.env.CL_APISECRET\r\n        });\r\n    }\r\n\r\n    static async getInstance(name) {\r\n        if (!CloudinaryService.instance) {\r\n            CloudinaryService.instance = new CloudinaryService();\r\n        }\r\n        await CloudinaryService.instance.getResourcesFromFolder(name);\r\n        return CloudinaryService.instance;\r\n    }\r\n\r\n    async getResourcesFromFolder(folderName) {\r\n        console.log('FETCHING NEW FILES!! from CLOUDINARY');\r\n        await this.findAndSaveResources(folderName, 'image');\r\n    }\r\n\r\n    async createNewFolder(folderName) {\r\n        await this.createFolder(folderName);\r\n        await this.uploadFilesToFolder(folderName);\r\n    }\r\n\r\n    async overwriteFile() {\r\n        const cloudinaryFileId = \"index_nbzca5.js\";\r\n        const localFilePath = \"./src/test.js\";\r\n\r\n        try {\r\n\r\n            const result = await cloudinary.v2.uploader.upload(localFilePath, {\r\n                resource_type: 'auto',\r\n                overwrite: true,\r\n                invalidate: true,\r\n                public_id: cloudinaryFileId\r\n            });\r\n            console.log(result);\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n\r\n    }\r\n\r\n    async findAndSaveResources(folderName, type) {\r\n        try {\r\n            const { resources } = await cloudinary.v2.api.resources({ resource_type: type, type: 'upload', prefix: folderName, max_results: 500 });\r\n            resources.forEach(async (resource) => {\r\n                try {\r\n                    this.resources.set(resource.public_id.split('/')[1].split('_')[0], resource.url);\r\n                    await saveFile(resource.url, resource.public_id.split('/')[1].split('_')[0]);\r\n                } catch (error) {\r\n                    console.log(resource);\r\n                    console.log(parseError(error))\r\n                }\r\n\r\n            });\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    async createFolder(folderName) {\r\n        try {\r\n            const result = await cloudinary.v2.api.create_folder(folderName);\r\n\r\n            return result;\r\n        } catch (error) {\r\n            console.error('Error creating folder:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Function to upload files from URLs to a specific folder in Cloudinary\r\n    async uploadFilesToFolder(folderName) {\r\n        const uploadPromises = Array.from(this.resources.entries()).map(async ([key, url]) => {\r\n            try {\r\n                const result = await cloudinary.v2.uploader.upload_large(url, {\r\n                    folder: folderName,\r\n                    resource_type: 'auto',\r\n                    public_id: key, // Set the key as the public_id\r\n                });\r\n\r\n                return result;\r\n            } catch (error) {\r\n                console.error('Error uploading file:', error);\r\n                throw error;\r\n            }\r\n        });\r\n\r\n        try {\r\n            return await Promise.all(uploadPromises);\r\n        } catch (error) {\r\n            console.error('Error uploading files:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async printResources() {\r\n        try {\r\n            this.resources?.forEach((val, key) => {\r\n                console.log(key, \":\", val);\r\n            })\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    get(publicId) {\r\n        try {\r\n            const result = this.resources.get(publicId)\r\n            return result || '';\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    getBuffer(publicId) {\r\n        try {\r\n            const result = this.resources.get(publicId)\r\n            return result || '';\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n}\r\n\r\nasync function saveFile(url, name) {\r\n    const extension = url.substring(url.lastIndexOf('.') + 1, url.length);\r\n    const mypath = path.resolve(__dirname, `./${name}.${extension}`);\r\n    fetchWithTimeout(url, { responseType: 'arraybuffer' }, 2)\r\n        .then(res => {\r\n            if (res?.statusText === 'OK') {\r\n                try {\r\n                    if (!fs.existsSync(mypath)) {\r\n                        fs.writeFileSync(mypath, res.data, 'binary'); // Save binary data as a file\r\n                        console.log(`${name}.${extension} Saved!!`);\r\n                    } else {\r\n                        fs.unlinkSync(mypath);\r\n                        fs.writeFileSync(mypath, res.data, 'binary'); // Save binary data as a file\r\n                        console.log(`${name}.${extension} Replaced!!`);\r\n                    }\r\n                } catch (err) {\r\n                    console.error(err);\r\n                }\r\n            } else {\r\n                throw new Error(`Unable to download file from ${url}`);\r\n            }\r\n        }).catch(err => {\r\n            console.error(err);\r\n        });\r\n}\r\n\r\n\r\n\r\n\r\n","import { MongoClient, ServerApiVersion, ConnectOptions, ObjectId } from 'mongodb';\r\nimport { isMatchingChatEntity } from './utils';\r\nimport mongoose from 'mongoose';\r\n\r\nexport class ChannelService {\r\n    static instance;\r\n    client = undefined\r\n    db = undefined;\r\n    users = undefined;\r\n    statsDb = undefined;\r\n    statsDb2 = undefined;\r\n    isConnected = false;\r\n\r\n    constructor () {\r\n    }\r\n\r\n    static getInstance() {\r\n        if (!ChannelService.instance) {\r\n            ChannelService.instance = new ChannelService();\r\n        }\r\n        return ChannelService.instance;\r\n    }\r\n    static isInstanceExist() {\r\n        return !!ChannelService.instance;\r\n    }\r\n\r\n    async connect() {\r\n        if (!this.isConnected) {\r\n            console.log('trying to connect to DB......')\r\n            try {\r\n                await mongoose.connect(process.env.mongouri, { useNewUrlParser: true, useUnifiedTopology: true, serverApi: ServerApiVersion.v1, maxPoolSize: 10 } );\r\n                console.log('Connected to MongoDB');\r\n                this.client = mongoose.connection.getClient()\r\n                this.isConnected = true;\r\n                this.client.on('close', () => {\r\n                    console.log('MongoDB connection closed.');\r\n                    this.isConnected = false;\r\n                });\r\n                this.db = this.client.db(\"tgclients\").collection('channels');\r\n                this.users = this.client.db(\"tgclients\").collection('users');\r\n                this.statsDb = this.client.db(\"tgclients\").collection('stats');\r\n                this.statsDb2 = this.client.db(\"tgclients\").collection('stats2');\r\n                return true;\r\n            } catch (error) {\r\n                console.log(`Error connecting to MongoDB: ${error}`);\r\n                return false;\r\n            }\r\n        } else {\r\n            console.log('MongoConnection ALready Existing');\r\n        }\r\n    }\r\n    async insertChannel(channelData) {\r\n        const {\r\n            title,\r\n            id,\r\n            username,\r\n            megagroup,\r\n            participantsCount,\r\n            restricted,\r\n            broadcast\r\n        } = channelData\r\n        const cannotSendMsgs = channelData.defaultBannedRights?.sendMessages\r\n        if (!cannotSendMsgs && !broadcast) {\r\n            await this.db.updateOne({ channelId: id.toString() }, { $set: { username: username, title, megagroup, participantsCount, broadcast, restricted, sendMessages: channelData.defaultBannedRights?.sendMessages, canSendMsgs: true } }, { upsert: true });\r\n        }\r\n    }\r\n\r\n    async insertContact(contact) {\r\n        const collection = this.client.db(\"tgclients\").collection('contacts');\r\n\r\n        await collection.updateOne({ phone: contact.phone }, { $set: contact }, { upsert: true });\r\n\r\n    }\r\n    async getChannels(limit = 50, skip = 0, k) {\r\n        const query = { megagroup: true, username: { $ne: null } };\r\n        const sort = { participantsCount: -1 };\r\n        if (k) {\r\n            query[\"$or\"] = [{ title: { $regex: k, $options: 'i' } }, { username: { $regex: k, $options: 'i' } }]\r\n        }\r\n        const options = { collation: { locale: 'en', strength: 1 } };\r\n        try {\r\n            if (k) {\r\n                await this.db?.createIndex({ title: 'text' }); // Create index on the \"title\" field for text search\r\n            }\r\n            const result = await this.db\r\n                .find(query, options)\r\n                .sort(sort)\r\n                .skip(skip)\r\n                .limit(limit)\r\n                .toArray();\r\n\r\n            return result;\r\n        } catch (error) {\r\n            console.error('Error:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    async insertUser(user) {\r\n        const filter = { mobile: user.mobile };\r\n        try {\r\n            const entry = await this.users.findOne(filter);\r\n            if (!entry) {\r\n                await this.users.insertOne(user);\r\n            }\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    // async calculateAvgStats() {\r\n    //     try {\r\n    //         const channelStatsDb = this.client.db(\"tgclients\").collection('channelStats'); // Replace with your source collection name\r\n    //         const activeChannelsDb = this.client.db(\"tgclients\").collection('activeChannels'); // Replace with your target collection name\r\n\r\n    //         const documents = await channelStatsDb.find({}).toArray();\r\n\r\n    //         for (const doc of documents) {\r\n    //             const { channelId, requestCounts } = doc;\r\n    //             if (requestCounts.length > 0) {\r\n    //                 const sum = requestCounts.reduce((acc, num) => acc + num, 0);\r\n    //                 const average = sum / requestCounts.length;\r\n\r\n    //                 const updateDoc = {\r\n    //                     rpm: Math.floor(average)\r\n    //                 };\r\n\r\n    //                 await activeChannelsDb.updateOne(\r\n    //                     { channelId },\r\n    //                     { $set: updateDoc },\r\n    //                     { upsert: true } // Create the document if it doesn't exist\r\n    //                 );\r\n\r\n    //                 await channelStatsDb.updateOne({ channelId }, { $set: { requestCounts: [], updatedAt: 0 } }, { upsert: true });\r\n\r\n    //                 console.log(`Processed chatId: ${channelId}, average: ${average}`);\r\n    //             }\r\n    //         }\r\n    //     } catch (error) {\r\n    //         console.error('Error while processing documents:', error);\r\n    //     }\r\n    // }\r\n\r\n\r\n    // async clearChannelStats() {\r\n    //     const channelStatsDb = this.client.db(\"tgclients\").collection('channelStats'); // Replace with your source collection name\r\n    //     const result = await channelStatsDb.deleteMany({});\r\n    //     console.log(\"deleted Channel Stats: \", result)\r\n    // }\r\n\r\n    async updateUser(user, data) {\r\n        const filter = { mobile: user.mobile };\r\n        try {\r\n            const entry = await this.users.updateOne(filter, {\r\n                $set: {\r\n                    ...data\r\n                },\r\n            }, { upsert: true });\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    async resetPaidUsers() {\r\n        try {\r\n            const collection = this.client.db(\"tgclients\").collection('userData');\r\n            const entry = await collection.updateMany({ $and: [{ payAmount: { $gt: 10 }, totalCount: { $gt: 30 } }] }, {\r\n                $set: {\r\n                    totalCount: 10,\r\n                    limitTime: Date.now(),\r\n                    paidReply: true\r\n                }\r\n            });\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    async deleteUser(user) {\r\n        const filter = { mobile: user.mobile };\r\n        try {\r\n            const entry = await this.users.deleteOne(filter);\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    async getUser(user) {\r\n        const filter = { mobile: user.mobile };\r\n        try {\r\n            const entry = await this.users.findOne(filter);\r\n            return entry\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n            return undefined\r\n        }\r\n    }\r\n\r\n    async getuserdata(filter) {\r\n        try {\r\n            const collection = this.client.db(\"tgclients\").collection('userData');\r\n            const entry = await collection.findOne(filter);\r\n            return entry\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n            return undefined\r\n        }\r\n    }\r\n\r\n    async updateUserData(filter, data) {\r\n        try {\r\n            const collection = this.client.db(\"tgclients\").collection('userData');\r\n            const entry = await collection.updateMany(filter, { $set: { ...data } });\r\n            return entry\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n            return undefined\r\n        }\r\n    }\r\n\r\n    async getTempUser() {\r\n        try {\r\n            const entry = await this.users.findOne({});\r\n            return entry\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    async getUsersFullData(limit = 2, skip = 0) {\r\n        const result = await this.users?.find({}).skip(skip).limit(limit).sort({ _id: 1 }).toArray();\r\n        if (result) {\r\n            return result;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    async insertInBufferClients(user) {\r\n        const filter = { mobile: user.mobile };\r\n        try {\r\n            const bufferColl = this.client.db(\"tgclients\").collection('bufferClients');\r\n            await bufferColl.updateOne(filter, { $set: { ...user } }, { upsert: true });\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    async readBufferClients(filter, limit) {\r\n        const bufferColl = this.client.db(\"tgclients\").collection('bufferClients');\r\n        const query = filter || {};\r\n        const queryWithLimit = limit ? bufferColl.find(query).limit(limit) : bufferColl.find(query);\r\n        const result = await queryWithLimit.toArray();\r\n        if (result?.length > 0) {\r\n            return result;\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n\r\n    async getOneBufferClient() {\r\n        const bufferColl = this.client.db(\"tgclients\").collection('bufferClients');\r\n        const result = await bufferColl.findOne({});\r\n        if (result) {\r\n            return result;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    async deleteBufferClient(user) {\r\n        const filter = { mobile: user.mobile };\r\n        const bufferColl = this.client.db(\"tgclients\").collection('bufferClients');\r\n        try {\r\n            const entry = await bufferColl.deleteOne(filter);\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    async getNewBufferClients(ids) {\r\n        const cursor = this.users.find({ \"mobile\": { $nin: ids }, twoFA: { $exists: false } }).sort({ lastActive: 1 }).limit(20);\r\n        return cursor\r\n    }\r\n\r\n    async readPromoteStats() {\r\n        const promotColl = this.client.db(\"tgclients\").collection('promoteStats');\r\n        const result = await promotColl.find({}, { projection: { \"client\": 1, \"totalCount\": 1, \"lastUpdatedTimeStamp\": 1, \"isActive\": 1, \"_id\": 0 } }).sort({ totalCount: -1 }).toArray();\r\n        if (result.length > 0) {\r\n            return result;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    async checkIfPaidToOthers(chatId, profile) {\r\n        const resp = { paid: 0, demoGiven: 0, secondShow: 0, fullShow: 0 };\r\n        try {\r\n            const collection = this.client.db(\"tgclients\").collection('userData');\r\n            const document = await collection.find({ chatId, profile: { $exists: true, \"$ne\": profile }, payAmount: { $gte: 10 } }).toArray();\r\n            const document2 = await collection.find({ chatId, profile: { $exists: true, \"$ne\": profile } }).toArray();\r\n            if (document.length > 0) {\r\n                resp.paid = document.length\r\n            }\r\n            if (document2.length > 0) {\r\n                document2.map(doc => {\r\n                    if (doc.demoGiven) {\r\n                        resp.demoGiven = resp.demoGiven + 1\r\n                    }\r\n                    if (doc.secondShow) {\r\n                        resp.secondShow = resp.secondShow + 1\r\n                    }\r\n                    if (doc.fullShow) {\r\n                        resp.fullShow = resp.fullShow + 1\r\n                    }\r\n                })\r\n            }\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n        return resp;\r\n    }\r\n\r\n\r\n    async readSinglePromoteStats(clientId) {\r\n        const promotColl = this.client.db(\"tgclients\").collection('promoteStats');\r\n        const result = await promotColl.findOne({ client: clientId }, { projection: { \"client\": 1, \"totalCount\": 1, \"lastUpdatedTimeStamp\": 1, \"isActive\": 1, \"_id\": 0 } });\r\n        return result\r\n    }\r\n\r\n    async readStats() {\r\n        const result = await this.statsDb.find({}).sort({ newUser: -1 })\r\n        if (result) {\r\n            return result.toArray();\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    async read(chatId) {\r\n        const result = await this.db.findOne({ chatId });\r\n        if (result) {\r\n            return result;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n    async removeOnefromChannel(filter) {\r\n        try {\r\n            await this.db.deleteOne(filter)\r\n        } catch (e) {\r\n            console.log(parseError(e))\r\n        }\r\n    }\r\n\r\n    async getUsers(limit, skip = 0) {\r\n        const result = await this.users?.find({}, { projection: { firstName: 1, userName: 1, mobile: 1, _id: 0 } }).skip(skip).limit(limit).toArray();\r\n        if (result) {\r\n            return result;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    async getupi(key) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('upi-ids');\r\n        const upiIds = await upiDb.findOne({});\r\n        return upiIds[key] || \"lakshmi-69@paytm\"\r\n    }\r\n\r\n    async getAllUpis() {\r\n        const upiDb = this.client.db(\"tgclients\").collection('upi-ids');\r\n        const upiIds = await upiDb.findOne({});\r\n        return upiIds\r\n    }\r\n\r\n    async updateUpis(data) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('upi-ids');\r\n        const upiIds = await upiDb.updateOne({}, { $set: { ...data } });\r\n        return upiIds\r\n    }\r\n\r\n    async getBuilds() {\r\n        const buildBd = this.client.db(\"tgclients\").collection('builds');\r\n        const builds = await buildBd.findOne({});\r\n        return builds\r\n    }\r\n\r\n    async updateBuilds(data) {\r\n        const buildBd = this.client.db(\"tgclients\").collection('builds');\r\n        const builds = await buildBd.updateOne({}, { $set: { ...data } }, { upsert: true });\r\n        return builds\r\n    }\r\n\r\n    async getUserConfig(filter) {\r\n        const clientDb = this.client.db(\"tgclients\").collection('clients');\r\n        const client = await clientDb.findOne(filter);\r\n        return client\r\n    }\r\n    async getUserInfo(filter) {\r\n        const clientDb = this.client.db(\"tgclients\").collection('clients');\r\n        const aggregationPipeline = [\r\n            { $match: filter },\r\n            {\r\n                $project: {\r\n                    \"_id\": 0,\r\n                    \"session\": 0,\r\n                    \"number\": 0,\r\n                    \"password\": 0,\r\n                }\r\n            }\r\n        ];\r\n        const result = await clientDb.aggregate(aggregationPipeline).toArray();\r\n        return result.length > 0 ? result[0] : null;\r\n    }\r\n    async updateUserConfig(filter, data) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('clients');\r\n        const updatedDocument = await upiDb.findOneAndUpdate(filter, { $set: { ...data } }, { returnOriginal: false });\r\n        return updatedDocument.value;\r\n    }\r\n\r\n    async insertInAchivedClient(data) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('ArchivedClients');\r\n        const upiIds = await upiDb.updateOne({ number: data.number }, { $set: { ...data } }, { upsert: true });\r\n        return upiIds\r\n    }\r\n\r\n    async getInAchivedClient(filter) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('ArchivedClients');\r\n        const upiIds = await upiDb.findOne(filter)\r\n        return upiIds\r\n    }\r\n\r\n    async getAllUserClients() {\r\n        const clientDb = this.client.db(\"tgclients\").collection('clients');\r\n        const clients = await clientDb.aggregate([\r\n            {\r\n                $project: {\r\n                    \"_id\": 0,\r\n                    \"session\": 0,\r\n                    \"number\": 0,\r\n                    \"password\": 0,\r\n                }\r\n            }\r\n        ]).toArray();\r\n        return clients;\r\n    }\r\n\r\n    async setEnv() {\r\n        const clientDb = this.client.db(\"tgclients\").collection('configuration');\r\n        const jsonData = await clientDb.findOne({}, { _id: 0 });\r\n        for (const key in jsonData) {\r\n            process.env[key] = jsonData[key];\r\n        }\r\n    }\r\n\r\n    async getTgConfig() {\r\n        const clientDb = this.client.db(\"tgclients\").collection('configuration');\r\n        const jsonData = await clientDb.findOne({}, { _id: 0 });\r\n        return jsonData\r\n    }\r\n\r\n    async updateTgConfig(data) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('configurations');\r\n        const upiIds = await upiDb.updateOne({}, { $set: { ...data } });\r\n        return upiIds\r\n    }\r\n\r\n    async processUsers(limit = undefined, skip = undefined) {\r\n        const weekAgo = new Date(Date.now() - (60 * 24 * 60 * 60 * 1000)).toISOString().split('T')[0]\r\n        const cursor = this.users.find({\r\n            $or: [\r\n                { \"lastUpdated\": { $lt: weekAgo } },\r\n                { \"lastUpdated\": { $exists: false } }\r\n            ]\r\n        }).limit(limit ? limit : 300).skip(skip ? skip : 0);\r\n        return cursor;\r\n    }\r\n\r\n    async clearStats() {\r\n        const result = await this.statsDb.deleteMany({ \"payAmount\": { $lt: 5 } });\r\n        console.log(result);\r\n    }\r\n\r\n    async clearAllStats() {\r\n        const result = await this.statsDb?.deleteMany({});\r\n        console.log(result);\r\n    }\r\n\r\n    async clearStats2() {\r\n        const result = await this.statsDb2?.deleteMany({});\r\n        console.log(result);\r\n    }\r\n\r\n    async reinitPromoteStats() {\r\n        const promotColl = this.client.db(\"tgclients\").collection('promoteStats');\r\n        const users = await this.getAllUserClients();\r\n        for (const user of users) {\r\n            await promotColl.updateOne({ client: user.clientId },\r\n                {\r\n                    $set: {\r\n                        data: Object.fromEntries((await promotColl.findOne({ client: user.clientId })).channels?.map(channel => [channel, 0])),\r\n                        totalCount: 0,\r\n                        uniqueChannels: 0,\r\n                        releaseDay: Date.now(),\r\n                        lastupdatedTimeStamp: Date.now()\r\n                    }\r\n                });\r\n        }\r\n    }\r\n\r\n    async closeConnection() {\r\n        try {\r\n            if (this.isConnected) {\r\n                this.isConnected = false;\r\n                console.log('MongoDB connection closed.');\r\n            }\r\n            await this.client?.close();\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    async getCurrentActiveUniqueChannels() {\r\n        const promoteStatsColl = this.client.db(\"tgclients\").collection('promoteStats');\r\n\r\n        const cursor = promoteStatsColl.find({});\r\n        const uniqueChannels = new Set();\r\n\r\n        await cursor.forEach((document) => {\r\n            for (const channel in document.data) {\r\n                uniqueChannels.add(channel);\r\n            }\r\n        });\r\n\r\n        const uniqueChannelNames = Array.from(uniqueChannels);\r\n        return uniqueChannelNames;\r\n    }\r\n\r\n    async getActiveChannels(limit = 50, skip = 0, keywords = [], notIds = [], collection = 'activeChannels') {\r\n        const pattern = new RegExp(keywords.join('|'), 'i');\r\n        const notPattern = new RegExp('online|board|class|PROFIT|@wholesale|retail|topper|exam|medico|traini|cms|cma|subject|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser', \"i\")\r\n        let query = {\r\n            $and: [\r\n                { username: { $ne: null } },\r\n                {\r\n                    $or: [\r\n                        { title: { $regex: pattern } },\r\n                        { username: { $regex: pattern } }\r\n                    ]\r\n                },\r\n                {\r\n                    username: {\r\n                        $not: {\r\n                            $regex: \"^(\" + notIds.map(id => \"(?i)\" + id?.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'))?.join(\"|\") + \")$\"\r\n                        }\r\n                    }\r\n                },\r\n                {\r\n                    title: { $not: { $regex: notPattern } }\r\n                },\r\n                {\r\n                    username: { $not: { $regex: notPattern } }\r\n                },\r\n                {\r\n                    sendMessages: false,\r\n                    broadcast: false,\r\n                    restricted: false\r\n                }\r\n            ]\r\n        };\r\n\r\n        const sort = { participantsCount: -1 };\r\n        const promoteStatsColl = this.client.db(\"tgclients\").collection(collection);\r\n        try {\r\n            const result = await promoteStatsColl\r\n                .find(query)\r\n                .sort(sort)\r\n                .skip(skip)\r\n                .limit(limit)\r\n                .toArray();\r\n\r\n            return result;\r\n        } catch (error) {\r\n            console.error('Error:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    async updateActiveChannels() {\r\n        try {\r\n            const promoteStatsColl = this.client.db(\"tgclients\").collection('promoteStats');\r\n            const activeChannelCollection = this.client.db(\"tgclients\").collection('activeChannels');\r\n            const channelInfoCollection = this.client.db(\"tgclients\").collection('channels');\r\n            const cursor = promoteStatsColl.find({});\r\n            await cursor.forEach(async (document) => {\r\n                for (const username in document.data) {\r\n                    const channelInfo = await channelInfoCollection.findOne({ username }, { projection: { \"_id\": 0 } });\r\n                    if (channelInfo) {\r\n                        let chat = {}\r\n                        const activeChannelInfo = await activeChannelCollection.findOne({ channelId: channelInfo.channelId }, { projection: { \"_id\": 0 } });\r\n                        if (!activeChannelInfo || (isMatchingChatEntity(channelInfo) && !(\"banned\" in activeChannelInfo))) {\r\n                            console.log(\"banned not exists: \", channelInfo);\r\n                            chat['channelId'] = channelInfo.channelId\r\n                            chat['title'] = channelInfo.title\r\n                            chat['participantsCount'] = channelInfo.participantsCount\r\n                            chat['username'] = channelInfo.username\r\n                            chat['restricted'] = channelInfo.restricted\r\n                            chat['broadcast'] = channelInfo.broadcast\r\n                            chat['sendMessages'] = channelInfo.sendMessages\r\n                            chat['canSendMsgs'] = channelInfo.canSendMsgs\r\n                            chat[\"banned\"] = false;\r\n                            chat[\"availableMsgs\"] = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\"];\r\n                            chat[\"wordRestriction\"] = 0;\r\n                            chat[\"dMRestriction\"] = 0\r\n                        }\r\n\r\n                        await activeChannelCollection.updateOne({ channelId: channelInfo.channelId }, { $set: channelInfo }, { upsert: true });\r\n                    }\r\n                }\r\n            });\r\n\r\n            const invalidChannelsCursor = await activeChannelCollection.find({ $or: [{ banned: { $exists: false } }, { participantsCount: null }, { participantsCount: { $exists: false } }] })\r\n            await invalidChannelsCursor.forEach(async (document) => {\r\n                const channelInfo = await channelInfoCollection.findOne({ channelId: document.channelId }, { projection: { \"_id\": 0 } }) || { participantsCount: 1200 };\r\n                await activeChannelCollection.updateOne({ channelId: document.channelId }, {\r\n                    $set: {\r\n                        ...channelInfo,\r\n                        banned: false,\r\n                        availableMsgs: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\"],\r\n                        wordRestriction: 0,\r\n                        dMRestriction: 0\r\n                    }\r\n\r\n                })\r\n            })\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    async updateActiveChannel(id, data) {\r\n        const activeChannelCollection = this.client.db(\"tgclients\").collection('activeChannels');\r\n        await activeChannelCollection.updateOne({ channelId: id }, { $set: data }, { upsert: true })\r\n    }\r\n\r\n    async updateBannedChannels() {\r\n        const activeChannelCollection = this.client.db(\"tgclients\").collection('activeChannels');\r\n        await activeChannelCollection.updateMany({ banned: true }, {\r\n            $set: {\r\n                \"wordRestriction\": 0,\r\n                \"dMRestriction\": 0,\r\n                banned: false,\r\n                \"availableMsgs\": [\r\n                    \"1\",\r\n                    \"2\",\r\n                    \"3\",\r\n                    \"4\",\r\n                    \"5\",\r\n                    \"6\",\r\n                    \"7\",\r\n                    \"8\",\r\n                    \"9\",\r\n                    \"10\",\r\n                    \"11\",\r\n                    \"12\",\r\n                    \"14\",\r\n                    \"15\",\r\n                    \"16\"\r\n                ]\r\n            }\r\n        })\r\n    }\r\n\r\n    async updateDefaultReactions() {\r\n        const activeChannelCollection = this.client.db(\"tgclients\").collection('activeChannels');\r\n        await activeChannelCollection.updateMany({}, {\r\n            $set: {\r\n                reactions: [\r\n                    '❤', '🔥', '👏', '🥰', '😁', '🤔',\r\n                    '🤯', '😱', '🤬', '😢', '🎉', '🤩',\r\n                    '🤮', '💩', '🙏', '👌', '🕊', '🤡',\r\n                    '🥱', '🥴', '😍', '🐳', '❤‍🔥', '💯',\r\n                    '🤣', '💔', '🏆', '😭', '😴', '👍',\r\n                    '🌚', '⚡', '🍌', '😐', '💋', '👻',\r\n                    '👀', '🙈', '🤝', '🤗', '🆒',\r\n                    '🗿', '🙉', '🙊', '🤷', '👎'\r\n                ]\r\n            }\r\n        })\r\n    }\r\n    async resetAvailableMsgs() {\r\n        try {\r\n            const promoteMsgs = this.client.db(\"tgclients\").collection('promoteMsgs');\r\n            const data = await promoteMsgs.findOne({}, { projection: { \"_id\": 0, \"0\": 0 } });\r\n            const keys = Object.keys(data);\r\n            const activeChannelCollection = this.client.db(\"tgclients\").collection('activeChannels');\r\n            await activeChannelCollection.updateMany({\r\n                $expr: {\r\n                    $lt: [{ $size: { $ifNull: [\"$availableMsgs\", []] } }, 5]\r\n                }\r\n            }, {\r\n                $set: {\r\n                    \"wordRestriction\": 0,\r\n                    \"dMRestriction\": 0,\r\n                    \"banned\": false,\r\n                    \"availableMsgs\": keys\r\n                }\r\n            })\r\n        } catch (e) {\r\n            console.log(parseError(e))\r\n        }\r\n    }\r\n\r\n    async removeOnefromActiveChannel(filter) {\r\n        try {\r\n            const activeChannelCollection = this.client.db(\"tgclients\").collection('activeChannels');\r\n            await activeChannelCollection.deleteOne(filter)\r\n        } catch (e) {\r\n            console.log(parseError(e))\r\n        }\r\n    }\r\n}\r\n\r\n","'use strict';\r\nimport dotenv from 'dotenv';\r\ndotenv.config();\r\n\r\nimport express from 'express';\r\nimport axios from 'axios';\r\nimport schedule from 'node-schedule-tz';\r\nimport { timeZone, timeZoneName } from 'node-schedule-tz'; // Assuming timeZone and timeZoneName are exported from node-schedule-tz\r\nimport { ChannelService } from './dbservice';\r\nimport {\r\n  getClient,\r\n  hasClient,\r\n  disconnectAll,\r\n  createClient,\r\n  deleteClient,\r\n  setActiveClientSetup,\r\n  getActiveClientSetup\r\n} from './telegramManager';\r\nimport bodyParser from 'body-parser';\r\nimport { sleep, fetchWithTimeout } from './utils';\r\nimport { execSync } from 'child_process';\r\nimport { CloudinaryService } from './cloudinary';\r\nimport fs from 'fs';\r\nimport { NestFactory } from '@nestjs/core';\r\nimport { ExpressAdapter } from '@nestjs/platform-express';\r\nimport { AppModule } from './nest/app.module';\r\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\r\nimport { parseError } from \"./utils\";\r\n\r\nconst timeOptions = { timeZone: 'Asia/Kolkata', timeZoneName: 'short' };\r\nprocess.on('unhandledRejection', (reason, promise) => {\r\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\r\n});\r\nprocess.on('exit', async () => {\r\n  await ChannelService.getInstance().closeConnection();\r\n  await disconnectAll();\r\n});\r\n\r\nvar cors = require('cors');\r\nconst app = express();\r\nconst port = process.env.PORT || 8000;\r\nconst userMap = new Map();\r\n\r\nlet ip;\r\nlet clients;\r\nlet upiIds;\r\nconst pings = {}\r\n\r\nfetchWithTimeout('https://ipinfo.io/json')\r\n  .then(result => {\r\n    return result?.data;\r\n  })\r\n  .then((output) => {\r\n    ip = output;\r\n    console.log(ip)\r\n  })\r\n  .then(async () => {\r\n    const db = ChannelService.getInstance()\r\n    await db.connect();\r\n    await db.setEnv();\r\n    setTimeout(async () => {\r\n      checkerclass.getinstance()\r\n      await setUserMap();\r\n    }, 100);\r\n  })\r\n  .catch(err => console.error(err))\r\n\r\nlet count = 0;\r\nlet botCount = 0\r\nconst ppplbot = (chatId, botToken) => {\r\n  let token = botToken;\r\n  if (!token) {\r\n    if (botCount % 2 == 1) {\r\n      token = `bot6624618034:AAHoM3GYaw3_uRadOWYzT7c2OEp6a7A61mY`\r\n    } else {\r\n      token = `bot6607225097:AAG6DJg9Ll5XVxy24Nr449LTZgRb5bgshUA`\r\n    }\r\n    botCount++;\r\n  }\r\n  return `https://api.telegram.org/${token}/sendMessage?chat_id=${chatId ? chatId : \"-1001801844217\"}`\r\n}\r\nconst pingerbot = `https://api.telegram.org/bot5807856562:${process.env.apikey}/sendMessage?chat_id=-1001703065531`;\r\n\r\nconst apiResp = {\r\n  INSTANCE_NOT_EXIST: \"INSTANCE_NOT_EXIST\",\r\n  CLIENT_NOT_EXIST: \"CLIENT_NOT_EXIST\",\r\n  CONNECTION_NOT_EXIST: \"CONNECTION_NOT_EXIST\",\r\n  ALL_GOOD: \"ALL_GOOD\",\r\n  DANGER: \"DANGER\",\r\n  WAIT: \"WAIT\"\r\n};\r\n\r\nasync function setUserMap() {\r\n  userMap.clear();\r\n  const db = ChannelService.getInstance();\r\n  await fetchWithTimeout(`${ppplbot()}&text=UptimeRobot : Refreshed Map`);\r\n  const users = await db.getAllUserClients();\r\n  clients = users\r\n  upiIds = await db.getAllUpis()\r\n  users.forEach(user => {\r\n    userMap.set(user.userName.toLowerCase(), { url: `${user.repl}/`, timeStamp: Date.now(), deployKey: user.deployKey, downTime: 0, lastPingTime: Date.now(), clientId: user.clientId })\r\n    pings[user.userName.toLowerCase()] = Date.now();\r\n  })\r\n}\r\n\r\nfunction getClientData(cid) {\r\n  const clients = Array.from(userMap.values())\r\n  return clients.find((value) => {\r\n    return value.clientId == cid\r\n  })\r\n}\r\n\r\nfunction getCurrentHourIST() {\r\n  const now = new Date();\r\n  const istOffset = 5.5 * 60 * 60 * 1000;\r\n  const istTime = new Date(now.getTime() + istOffset);\r\n  const istHour = istTime.getUTCHours();\r\n  return istHour;\r\n}\r\nconst connetionQueue = [];\r\ntry {\r\n  schedule.scheduleJob('test', ' 0 * * * * ', 'Asia/Kolkata', async () => {\r\n    console.log(\"Promoting.....\");\r\n    const hour = getCurrentHourIST();\r\n    const db = ChannelService.getInstance();\r\n    // await db.clearChannelStats();\r\n\r\n    const userValues = Array.from(userMap.values());\r\n    for (let i = 0; i < userValues.length; i++) {\r\n      const value = userValues[i];\r\n      await fetchWithTimeout(`${value.url}assureppl`);\r\n      await sleep(3000);\r\n      await fetchWithTimeout(`${value.url}promote`);\r\n      await sleep(2000);\r\n      if (hour && hour % 3 === 0) {\r\n        await fetchWithTimeout(`${value.url}calltopaid`);\r\n      }\r\n    }\r\n\r\n    await db.clearStats();\r\n    // await db.calculateAvgStats();\r\n    await fetchWithTimeout(`${process.env.uptimeChecker}/processusers/400/0`);\r\n  })\r\n\r\n  // schedule.scheduleJob('test1', ' 2 3,6,10,16,20,22 * * * ', 'Asia/Kolkata', async () => {\r\n  //     const userValues = Array.from(userMap.values());\r\n  // for (let i = 0; i < userValues.length; i++) {\r\n  //   const value = userValues[i];\r\n  //   })\r\n  // })\r\n\r\n  schedule.scheduleJob('test2', '*/10 * * * *', 'Asia/Kolkata', async () => {\r\n    const userValues = Array.from(userMap.values());\r\n    for (let i = 0; i < userValues.length; i++) {\r\n      const value = userValues[i];\r\n      await fetchWithTimeout(`${value.url}markasread`);\r\n      await sleep(3000);\r\n    }\r\n  })\r\n\r\n  schedule.scheduleJob('test3', ' 15 7,13,16,21,23 * * * ', 'Asia/Kolkata', async () => {\r\n    const userValues = Array.from(userMap.values());\r\n    for (let i = 0; i < userValues.length; i++) {\r\n      const value = userValues[i];\r\n      await fetchWithTimeout(`${value.url}asktopay`);\r\n      await sleep(3000);\r\n    }\r\n\r\n  })\r\n\r\n  schedule.scheduleJob('test3', ' 25 0 * * * ', 'Asia/Kolkata', async () => {\r\n    const db = ChannelService.getInstance();\r\n    for (const value of userMap.values()) {\r\n      await sleep(1000);\r\n      await fetchWithTimeout(`${value.url}resetunpaid`);\r\n      // await fetchWithTimeout(`${value.url}resetunppl`);\r\n      await fetchWithTimeout(`${value.url}getuserstats2`);\r\n      const now = new Date();\r\n      if (now.getUTCDate() % 5 === 1) {\r\n        setTimeout(async () => {\r\n          await db.resetAvailableMsgs();\r\n          await db.updateBannedChannels();\r\n          await db.updateDefaultReactions();\r\n        }, 30000);\r\n      }\r\n      setTimeout(async () => {\r\n        await fetchWithTimeout(`${value.url}asktopay`);\r\n      }, 300000);\r\n      await sleep(1000)\r\n    }\r\n\r\n    await fetchWithTimeout(`${ppplbot()}&text=${encodeURIComponent(await getPromotionStatsPlain())}`);\r\n    await db.resetPaidUsers();\r\n    await db.updateActiveChannels();\r\n    await db.clearStats2();\r\n    await db.clearAllStats();\r\n    await db.reinitPromoteStats();\r\n\r\n    try {\r\n      const resp = await fetchWithTimeout(`https://mychatgpt-pg6w.onrender.com/getstats`, { timeout: 55000 });\r\n      const resp2 = await fetchWithTimeout(`https://mychatgpt-pg6w.onrender.com/clearstats`, { timeout: 55000 });\r\n    } catch (error) {\r\n      console.log(\"Some Error: \", parseError(error), error.code)\r\n    }\r\n\r\n  })\r\n} catch (error) {\r\n  console.log(\"Some Error: \", parseError(error), error.code);\r\n}\r\n\r\nasync function assure() {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}resptopaid?msg=Hey...Dont worry!! I will Call you pakka ok!!`);\r\n    setTimeout(async () => {\r\n      await fetchWithTimeout(`${value.url}markasread?all=true`);\r\n    }, 20000)\r\n    await sleep(3000)\r\n  }\r\n}\r\n\r\napp.use(cors());\r\napp.use(bodyParser.json());\r\napp.get('/', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n\r\n  //\r\n});\r\n\r\napp.get('/exitacc', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  //\r\n});\r\n\r\napp.get('/processUsers/:limit/:skip', async (req, res, next) => {\r\n  res.send(\"ok\")\r\n  next();\r\n}, async (req, res) => {\r\n  const limit = req.params.limit ? req.params.limit : 30\r\n  const skip = req.params.skip ? req.params.skip : 20\r\n  const db = await ChannelService.getInstance();\r\n  const cursor = await db.processUsers(parseInt(limit), parseInt(skip));\r\n  while (await cursor.hasNext()) {\r\n    const document = await cursor.next();\r\n    console.log(\"In processUsers\")\r\n    const cli = await createClient(document.mobile, document.session);\r\n    const client = await getClient(document.mobile);\r\n    if (cli) {\r\n      console.log(document.mobile, \" :  true\");\r\n      const lastActive = await client.getLastActiveTime();\r\n      const date = new Date(lastActive * 1000).toISOString().split('T')[0];\r\n      const me = await client.getMe()\r\n      const selfMSgInfo = await client.getSelfMSgsInfo();\r\n      let gender = cli.gender;\r\n      if (!gender) {\r\n        const data = await fetchWithTimeout(`https://api.genderize.io/?name=${me.firstName}%20${me.lastName}`);\r\n        gender = data?.data?.gender;\r\n      }\r\n      await db.updateUser(document, { ...selfMSgInfo, gender, firstName: me.firstName, lastName: me.lastName, username: me.username, msgs: cli.msgs, totalChats: cli.total, lastActive, date, tgId: me.id.toString(), lastUpdated: new Date().toISOString().split('T')[0] });\r\n      await client?.disconnect(document.mobile);\r\n      await deleteClient()\r\n    } else {\r\n      console.log(document.mobile, \" :  false\");\r\n      await db.deleteUser(document);\r\n    }\r\n  }\r\n  console.log(\"finished\")\r\n});\r\n\r\napp.get('/refreshMap', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  await setUserMap();\r\n  res.send('Hello World!');\r\n});\r\n\r\napp.get('/clearstats2', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  await db.clearStats2();\r\n  res.send('Hello World!');\r\n});\r\n\r\napp.get('/updateBannedChannels', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  await db.updateBannedChannels();\r\n  res.send('Hello World!');\r\n});\r\napp.get('/resetAvailableMsgs', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  await db.resetAvailableMsgs();\r\n  res.send('Hello World!');\r\n});\r\n\r\napp.get('/exit', async (req, res) => {\r\n  await ChannelService.getInstance().closeConnection();\r\n  process.exit(1)\r\n  res.send('Hello World!');\r\n});\r\n\r\napp.post('/channels', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  // console.log(req.body);\r\n  next();\r\n}, async (req, res) => {\r\n  const channels = req.body?.channels;\r\n  const db = ChannelService.getInstance();\r\n  channels?.forEach(async (channel) => {\r\n    await db.insertChannel(channel);\r\n  })\r\n});\r\n\r\napp.post('/contacts', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  // console.log(req.body);\r\n  next();\r\n}, async (req, res) => {\r\n  const contacts = req.body?.contacts;\r\n  const db = ChannelService.getInstance();\r\n  contacts?.forEach(async (contact) => {\r\n    await db.insertContact(contact);\r\n  })\r\n  console.log('contacts saved', contacts.length);\r\n});\r\n\r\napp.get('/getip', (req, res) => {\r\n  res.json(ip);\r\n});\r\n\r\napp.post('/users', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  console.log(req.body);\r\n  next();\r\n}, async (req, res) => {\r\n  const user = req.body;\r\n  const db = ChannelService.getInstance();\r\n  await db.insertUser(user);\r\n  await fetchWithTimeout(`${ppplbot()}&text=ACCOUNT LOGIN: ${user.userName ? user.userName : user.firstName}:${user.msgs}:${user.totalChats}\\n ${process.env.uptimeChecker}/connectclient/${user.mobile}`)\r\n});\r\n\r\napp.get('/channels/:limit/:skip', async (req, res, next) => {\r\n  const limit = req.params.limit ? req.params.limit : 30\r\n  const skip = req.params.skip ? req.params.skip : 20\r\n  const k = req.query?.k\r\n  const db = ChannelService.getInstance();\r\n  const channels = await db.getChannels(parseInt(limit), parseInt(skip), k);\r\n  let resp = 'joinchannel:'\r\n  for (const channel of channels) {\r\n    resp = resp + (channel?.username?.startsWith(\"@\") ? channel.username : `@${channel.username}`) + \"|\";\r\n  }\r\n  res.send(resp);\r\n});\r\n\r\napp.get('/activechannels/:limit/:skip', async (req, res, next) => {\r\n  const limit = req.params.limit ? req.params.limit : 30\r\n  const skip = req.params.skip ? req.params.skip : 20\r\n  const k = req.query?.k\r\n  const db = ChannelService.getInstance();\r\n  const result = await db.getActiveChannels(parseInt(limit), parseInt(skip), [k], [], 'channels');\r\n  let resp = 'joinchannel:'\r\n  for (const channel of result) {\r\n\r\n    resp = resp + (channel?.username?.startsWith(\"@\") ? channel.username : `@${channel.username}`) + \"|\";\r\n  }\r\n  res.send(resp);\r\n});\r\n\r\nlet refresTime = Date.now();\r\napp.get('/getdata', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  if (Date.now() > refresTime) {\r\n    refresTime = Date.now() + (5 * 60 * 1000);\r\n  }\r\n  res.setHeader('Content-Type', 'text/html');\r\n  let resp = '<html><head></head><body>';\r\n  resp = resp + await getData();\r\n  resp += '</body></html>';\r\n  resp += `<script>\r\n              console.log(\"hii\");\r\n              setInterval(() => {\r\n                window.location.reload();\r\n              }, 20000);\r\n          </script>`;\r\n  res.send(resp);\r\n});\r\n\r\napp.get('/getdata2', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}getDemostat2`);\r\n    await sleep(1000);\r\n  }\r\n});\r\n\r\napp.get('/getAllIps', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    try {\r\n      console.log(value.clientId)\r\n      const res = await fetchWithTimeout(`${value.url}getip`);\r\n      console.log(res.data);\r\n    } catch (error) {\r\n\r\n    }\r\n  }\r\n});\r\n\r\napp.get('/refreshupis', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}refreshupis`);\r\n  }\r\n});\r\n\r\n\r\napp.get('/getviddata', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  const chatId = req.query.chatId;\r\n  let profile = req.query.profile;\r\n  if (!profile && req.query.clientId) {\r\n    profile = req.query.clientId?.replace(/\\d/g, '')\r\n  }\r\n  const db = ChannelService.getInstance();\r\n  const data = await db.getuserdata({ chatId, profile });\r\n  res.json(data);\r\n});\r\n\r\napp.post('/getviddata', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  let profile = req.query.profile;\r\n  if (!profile && req.query.clientId) {\r\n    profile = req.query.clientId?.replace(/\\d/g, '')\r\n  }\r\n  const body = req.body;\r\n  const chatId = body.chatId;\r\n  const db = ChannelService.getInstance();\r\n  const data = await db.updateUserData({ chatId, profile }, body);\r\n  res.json(data);\r\n});\r\n\r\napp.get('/blockUser/:profile/:chatId', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  let profile = req.params.profile;\r\n  const chatId = req.params.chatId;\r\n  const db = ChannelService.getInstance();\r\n  const data = await db.updateUserData({ chatId, profile }, { canReply: 0, payAmount: 0 });\r\n  res.json(data);\r\n});\r\n\r\napp.get('/sendvclink', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  const chatId = req.query.chatId;\r\n  const video = req.query.video;\r\n  const profile = req.query.clientId;\r\n  const client = getClientData(profile);\r\n  const url = `${client?.url}sendvclink/${chatId}?${video ? `video=${video}` : \"\"}`;\r\n  console.log(url);\r\n  await fetchWithTimeout(url);\r\n  res.send(\"done\");\r\n});\r\n\r\napp.get('/sendvclink/:clientId/:chatId', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  const clientId = req.params.clientId;\r\n  const chatId = req.params.chatId;\r\n  const video = req.query.video;\r\n  const client = getClientData(clientId);\r\n  const url = `${client?.url}sendvclink/${chatId}?${video ? `video=${video}` : \"\"}`;\r\n  console.log(url);\r\n  await fetchWithTimeout(url);\r\n  res.send(\"done\");\r\n});\r\n\r\napp.get('/blockUserall/:chatId', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  const chatId = req.params.chatId;\r\n  const db = ChannelService.getInstance();\r\n  const data = await db.updateUserData({ chatId }, { canReply: 0, payAmount: 0 });\r\n  res.json(data);\r\n});\r\n\r\napp.get('/getuserdata', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}getuserstats`);\r\n    await sleep(1000);\r\n  }\r\n});\r\n\r\napp.get('/getuserdata2', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}getuserstats2`);\r\n    await sleep(1000);\r\n  }\r\n});\r\n\r\napp.get('/restartall', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.deployKey}`);\r\n    await sleep(1000)\r\n  }\r\n});\r\napp.get('/sendtoall', async (req, res, next) => {\r\n  checkerclass.getinstance();\r\n  console.log('Received sendtoall request');\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const queries = req.query\r\n  let newQuery = '';\r\n  Object.keys(req.query).map((key) => {\r\n    newQuery += `/${queries[key]}`\r\n  });\r\n  console.log(newQuery);\r\n  for (const value of userMap.values()) {\r\n    const url = `${value.url.slice(0, -1)}${newQuery}`;\r\n    console.log(url);\r\n    await sleep(1000);\r\n    await fetchWithTimeout(url);\r\n  }\r\n});\r\n\r\napp.get('/usermap', async (req, res) => {\r\n  checkerclass.getinstance()\r\n  console.log('Received Usermap request');\r\n  res.json({ values: Array.from(userMap.values()), keys: userMap.keys() });\r\n});\r\n\r\napp.get('/getbufferclients', async (req, res) => {\r\n  const db = ChannelService.getInstance();\r\n  const result = []\r\n  const clients = await db.readBufferClients({});\r\n  clients.forEach((cli) => {\r\n    result.push(cli.mobile);\r\n  })\r\n  res.json(result);\r\n});\r\n\r\napp.get('/clients', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  console.log('Received Client request');\r\n  res.json(clients)\r\n});\r\n\r\napp.get('/keepready2', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  console.log('Received keepready2 request');\r\n  res.send(`Responding!!\\nMsg = ${req.query.msg}`);\r\n  next();\r\n}, async (req, res) => {\r\n  const msg = req.query.msg;\r\n  console.log(\"Msg2 = \", msg);\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}resptopaid2?msg=${msg ? msg : \"Oye...\"}`);\r\n    await fetchWithTimeout(`${value.url}getDemostats`);\r\n    await sleep(1000)\r\n  }\r\n  const db = ChannelService.getInstance();\r\n  await db.clearStats()\r\n});\r\n\r\napp.get('/keepready', async (req, res, next) => {\r\n  checkerclass.getinstance();\r\n  console.log('Received Keepready request');\r\n  const dnsMsg = encodeURIComponent(`Dont Speak Okay!!\\n**I am in Bathroom**\\n\\nMute yourself!!\\n\\nI will show you Okay..!!`)\r\n  const msg = req.query.msg.toLowerCase() == 'dns' ? dnsMsg : req.query.msg;\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}resptopaid?msg=${msg ? msg : \"Oye...\"}`);\r\n    await sleep(1000)\r\n  }\r\n  const db = ChannelService.getInstance();\r\n  await db.clearStats();\r\n  res.send(`Responding!!\\=url:resptopaid?msg=${msg ? msg : \"Oye...\"}`);\r\n});\r\n\r\napp.get('/asktopay', async (req, res, next) => {\r\n  checkerclass.getinstance();\r\n  console.log('Received AsktoPay request');\r\n  res.send(`Asking Pppl`);\r\n  next();\r\n}, async (req, res) => {\r\n  const msg = req.query.msg;\r\n  console.log(\"Msg = \", msg);\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}asktopay`)\r\n    await sleep(1000)\r\n  }\r\n});\r\n\r\nlet callingTime = Date.now();\r\napp.get('/calltopaid', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  console.log('Received Call request');\r\n  res.send(`Asking Pppl`);\r\n  next();\r\n}, async (req, res) => {\r\n  const msg = req.query.msg;\r\n  console.log(\"Msg = \", msg);\r\n  if (Date.now() > callingTime) {\r\n    callingTime = Date.now() + (10 * 60 * 1000)\r\n    const userValues = Array.from(userMap.values());\r\n    for (let i = 0; i < userValues.length; i++) {\r\n      const value = userValues[i];\r\n      await fetchWithTimeout(`${value.url}calltopaid`)\r\n      await sleep(1000)\r\n    }\r\n  }\r\n});\r\n\r\n\r\napp.get('/markasread', async (req, res, next) => {\r\n  checkerclass.getinstance();\r\n  console.log('Received MarkasRead Req');\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const all = req.query.all;\r\n  if (Date.now() > refresTime) {\r\n    refresTime = Date.now() + (5 * 60 * 1000);\r\n    console.log(\"proceeding with all = \", all);\r\n    const userValues = Array.from(userMap.values());\r\n    for (let i = 0; i < userValues.length; i++) {\r\n      const value = userValues[i];\r\n      await fetchWithTimeout(`${value.url}markasread?${all ? \"all=true\" : ''}`);\r\n      await sleep(3000)\r\n    }\r\n  }\r\n});\r\n\r\napp.get('/setactiveqr', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const upi = req.query.upi;\r\n  console.log(\"upi = \", upi);\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}setactiveqr?upi=${upi}`);\r\n    await sleep(1000)\r\n  }\r\n});\r\n\r\napp.get('/joinchannel', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const userName = req.query.userName;\r\n    if (userName) {\r\n      const data = userMap.get(userName.toLowerCase());\r\n      if (data) {\r\n        joinchannels(data)\r\n      } else {\r\n        console.log(new Date(Date.now()).toLocaleString('en-IN', timeOptions), `User ${userName} Not exist`);\r\n      }\r\n    } else {\r\n      const userValues = Array.from(userMap.values());\r\n      for (let i = 0; i < userValues.length; i++) {\r\n        const value = userValues[i];\r\n        try {\r\n          joinchannels(value);\r\n          await sleep(3000);\r\n        } catch (error) {\r\n          console.log(\"Some Error: \", parseError(error), error.code);\r\n        }\r\n        await sleep(1000)\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error);\r\n  }\r\n});\r\n\r\n\r\napp.get('/getUpiId', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const app = req.query.app ? req.query.app : \"paytm3\"\r\n  const db = ChannelService.getInstance();\r\n  const upiId = await db.getupi(app);\r\n  res.send(upiId);\r\n});\r\n\r\napp.get('/getAllUpiIds', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  res.json(upiIds);\r\n});\r\n\r\napp.post('/getAllUpiIds', async (req, res, next) => {\r\n  const data = req.body\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const upiIds = await db.updateUpis(data);\r\n  res.json(upiIds);\r\n  next();\r\n}, async () => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}refreshupis`);\r\n  }\r\n})\r\n\r\napp.get('/getUserConfig', async (req, res) => {\r\n  const filter = req.query\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const userConfig = await db.getUserConfig(filter);\r\n  res.json(userConfig);\r\n});\r\n\r\napp.get('/getUserInfo', async (req, res) => {\r\n  const filter = req.query\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const userConfig = await db.getUserInfo(filter);\r\n  res.json(userConfig);\r\n});\r\n\r\napp.post('/updateUserData/:chatId ', async (req, res) => {\r\n  const data = req.body\r\n  const chatId = req.params.chatId\r\n  const profile = req.query.profile;\r\n  checkerclass.getinstance();\r\n  const filter = { chatId }\r\n  if (profile) {\r\n    filter['profile'] = profile\r\n  }\r\n  const db = ChannelService.getInstance();\r\n  const userConfig = await db.updateUserData(filter, data);\r\n  res.json(userConfig);\r\n});\r\n\r\napp.post('/getUserConfig', async (req, res) => {\r\n  const filter = req.query\r\n  const data = req.body\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const upiIds = await db.updateUserConfig(filter, data);\r\n  await setUserMap();\r\n  res.json(upiIds);\r\n});\r\n\r\n\r\napp.get('/builds', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const data = await db.getBuilds();\r\n  console.log(data);\r\n  res.json(data);\r\n});\r\n\r\napp.post('/builds', async (req, res) => {\r\n  const data = req.body\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  console.log(data);\r\n  const result = await db.updateBuilds(data);\r\n  res.json(result);\r\n});\r\n\r\napp.get('/getAllUserClients', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const userConfig = await db.getAllUserClients();\r\n  const resp = []\r\n  userConfig.map((user) => {\r\n    resp.push(user.clientId)\r\n  })\r\n  res.send(resp);\r\n});\r\n\r\napp.get('/getTgConfig', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const tgConfig = await db.getTgConfig()\r\n  res.json(tgConfig);\r\n});\r\n\r\napp.get('/updateActiveChannels', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const tgConfig = await db.updateActiveChannels();\r\n  res.send(\"ok\");\r\n});\r\n\r\napp.get('/getCurrentActiveUniqueChannels', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const result = await db.getCurrentActiveUniqueChannels();\r\n  res.json({ length: result.length, data: result });\r\n});\r\n\r\napp.post('/getTgConfig', async (req, res, next) => {\r\n  const data = req.body\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const upiIds = await db.updateUpis(data)\r\n  res.json(upiIds);\r\n  next();\r\n}, async () => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}refreshupis`);\r\n  }\r\n});\r\n\r\napp.get('/lastpings', async (req, res, next) => {\r\n  checkerclass.getinstance();\r\n  let resp = '<html><head><style>pre { font-size: 18px; }</style></head><body><pre>';\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    resp = resp + `${value.clientId}  :  ${Number(((Date.now() - value.lastPingTime) / 60000).toFixed(2))}\\n`\r\n  }\r\n  resp += '</pre></body></html>';\r\n  res.setHeader('Content-Type', 'text/html');\r\n  res.send(resp);\r\n});\r\n\r\napp.get('/lastpingsjson', async (req, res, next) => {\r\n  checkerclass.getinstance();\r\n  let resp = '<html><head><style>pre { font-size: 18px; }</style></head><body><pre>';\r\n  for (const userdata in pings) {\r\n    resp = resp + `${userdata}  :  ${Number(((Date.now() - pings[userdata]) / 60000).toFixed(2))}\\n`\r\n  }\r\n  resp += '</pre></body></html>';\r\n  res.setHeader('Content-Type', 'text/html');\r\n  res.send(resp);\r\n});\r\n\r\napp.get('/exitglitches', async (req, res, next) => {\r\n  res.send(\"ok\")\r\n  next();\r\n}, async () => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    if (value.url.toLowerCase().includes('glitch'))\r\n      await fetchWithTimeout(`${value.url}exit`);\r\n  }\r\n});\r\n\r\napp.get('/exitprimary', async (req, res, next) => {\r\n  res.send(\"ok\")\r\n  next();\r\n}, async () => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    if (value.clientId.toLowerCase().includes('1')) {\r\n      await fetchWithTimeout(`${value.url}exit`);\r\n      await sleep(40000);\r\n    }\r\n  }\r\n});\r\n\r\napp.get('/exitsecondary', async (req, res, next) => {\r\n  res.send(\"ok\")\r\n  next();\r\n}, async () => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    if (value.clientId.toLowerCase().includes('2')) {\r\n      await fetchWithTimeout(`${value.url}exit`);\r\n      await sleep(40000)\r\n    }\r\n  }\r\n});\r\n\r\napp.get('/connectclient2/:number', async (req, res) => {\r\n  const number = req.params?.number;\r\n  const db = ChannelService.getInstance();\r\n  const user = await db.getUser({ mobile: number });\r\n  if (user) {\r\n    const buttonHtml = `<button id='btn' style=\"width: 50vw; height: 30vw; border-radius:20px;font-size:4vh\"  onclick=\"triggerHtmlRequest('${user.mobile}', '${user.session}')\">Create Client</button>\r\n    <script>\r\n      function triggerHtmlRequest(mobile, session) {\r\n        console.log(${number})\r\n        const button = document.getElementById('btn')\r\n        const request = new XMLHttpRequest();\r\n        request.open('GET', '${process.env.uptimeChecker}/cc/' + ${number}, true);\r\n        request.onload = function() {\r\n          if (request.status >= 200 && request.status < 400) {\r\n            button.innerHTML = request.responseText;\r\n          } else {\r\n            console.error('Failed to fetch URL');\r\n          }\r\n        };\r\n        request.send();\r\n        }\r\n    </script>`\r\n    res.send(`<html><body style=\"justify-content: center; display: flex;align-items:center;font-size:5vh\"><b style=\"display:block\"><h6>User Exists</h6>${buttonHtml}</b></body></html>`);\r\n  } else {\r\n    res.send(\"<html><body style='justify-content: center; display: flex;align-items:center;font-size:5vh'>User Does not exist</body></html>\");\r\n  }\r\n});\r\n\r\n// Second API to create the client when the button is clicked\r\napp.get('/cc/:number', async (req, res) => {\r\n  const number = req.params?.number;\r\n  if (!hasClient(number)) {\r\n    console.log(\"In createclient - \", req.ip);\r\n    const cli = await createClient(number, /* Add user session here */);\r\n    if (cli) {\r\n      res.send(\"client created\");\r\n    } else {\r\n      res.send(\"client EXPIRED\");\r\n    }\r\n  } else {\r\n    res.send(\"Client Already existing\");\r\n  }\r\n});\r\n\r\n\r\napp.get('/connectclient/:number', async (req, res) => {\r\n  const number = req.params?.number;\r\n  const db = ChannelService.getInstance();\r\n  const user = await db.getUser({ mobile: number });\r\n  if (user) {\r\n    if (!hasClient(user.mobile)) {\r\n      console.log(\"In connectclient - \", req.ip)\r\n      const cli = await createClient(user.mobile, user.session);\r\n      if (cli) {\r\n        res.send(\"client created\");\r\n      } else {\r\n        res.send(\"client EXPIRED\");\r\n      }\r\n    } else {\r\n      res.send(\"Client Already existing\");\r\n    }\r\n  } else {\r\n    res.send(\"User Does not exist\");\r\n  }\r\n});\r\n\r\napp.get('/sendToChannel', async (req, res, next) => {\r\n  res.send(\"sendToChannel\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const message = req.query?.msg;\r\n    const chatId = req.query?.chatId;\r\n    const token = req.query?.token;\r\n    await fetchWithTimeout(`${ppplbot(chatId, token)}&text=${decodeURIComponent(message)}`, {}, 3)\r\n  } catch (e) {\r\n    console.log(parseError(e));\r\n  }\r\n})\r\n\r\napp.get('/joinchannels/:number/:limit/:skip', async (req, res, next) => {\r\n  res.send(\"joiningChannels\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const limit = req.params.limit ? req.params.limit : 30\r\n    const skip = req.params.skip ? req.params.skip : 20\r\n    const k = req.query?.k\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    if (!hasClient(user.mobile)) {\r\n      console.log(\"In joinchannels\")\r\n      const cli = await createClient(user.mobile, user.session, false);\r\n      if (cli) {\r\n        const client = await getClient(user.mobile);\r\n        const channels = await client.channelInfo(true);\r\n        const keys = ['wife', 'adult', 'lanj', 'lesb', 'paid', 'randi', 'bhab', 'boy', 'girl'];\r\n        const result = await db.getActiveChannels(parseInt(limit), parseInt(skip), k ? [k] : keys, channels.ids, 'channels');\r\n        console.log(\"DbChannelsLen: \", result.length);\r\n        let resp = '';\r\n        for (const channel of result) {\r\n\r\n          resp = resp + (channel?.username?.startsWith(\"@\") ? channel.username : `@${channel.username}`) + \"|\";\r\n        }\r\n        await client.removeOtherAuths();\r\n        client.joinChannels(resp);\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error)\r\n  }\r\n});\r\n\r\napp.get('/getuser/:number/:u', async (req, res, next) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const username = req.params?.u;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    if (!hasClient(user.mobile)) {\r\n      console.log(\"In getuser\")\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      console.log(\"Connected\");\r\n      if (cli) {\r\n        console.log(\"checking for :\", username)\r\n        const res = await client.getchatId(username)\r\n        return (res)\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    } else {\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        const res = await client.getchatId(username)\r\n        return (res)\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error.code)\r\n  }\r\n});\r\n\r\napp.get('/set2fa/:number', async (req, res, next) => {\r\n  res.send(\"Setting 2FA\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    if (!hasClient(user.mobile)) {\r\n      console.log(\"In set2fa\")\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.set2fa();\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error.code)\r\n  }\r\n});\r\n\r\napp.get('/setpp/:number/:name', async (req, res, next) => {\r\n  res.send(\"Setting 2FA\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const name = req.params?.name;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    if (!hasClient(user.mobile)) {\r\n      console.log(\"In setpp\")\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await CloudinaryService.getInstance(name);\r\n        await sleep(2000);\r\n        await client.updateProfilePic('./dp1.jpg');\r\n        await sleep(1000);\r\n        await client.updateProfilePic('./dp2.jpg');\r\n        await sleep(1000);\r\n        await client.updateProfilePic('./dp3.jpg');\r\n        await sleep(1000);\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error.code)\r\n  }\r\n});\r\n\r\n\r\napp.get('/SetAsBufferClient/:number', async (req, res, next) => {\r\n  res.send(\"Updating Name\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    console.log(user);\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.set2fa();\r\n        await sleep(30000)\r\n        await client.updateUsername();\r\n        await sleep(5000)\r\n        await client.updatePrivacyforDeletedAccount();\r\n        await sleep(5000)\r\n        await client.updateProfile(\"Deleted Account\", \"Deleted Account\");\r\n        await sleep(5000)\r\n        await client.deleteProfilePhotos();\r\n        await sleep(5000)\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error)\r\n  }\r\n});\r\n\r\n\r\napp.get('/updatePrivacy/:number', async (req, res, next) => {\r\n  res.send(\"Updating Privacy\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    console.log(user);\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.updatePrivacy();\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error)\r\n  }\r\n});\r\n\r\napp.get('/forward*', async (req, res) => {\r\n  let targetHost = 'https://ramyaaa1.onrender.com';\r\n  if (req.query.host) {\r\n    targetHost = req.query.host;\r\n  }\r\n  try {\r\n    console.log(req.url);\r\n    const finalUrl = `${targetHost}${req.url.replace('/forward', '')}`\r\n    console.log(\"final:\", finalUrl)\r\n    const response = await fetchWithTimeout(finalUrl)\r\n    res.status(response?.status).send(response?.data);\r\n  } catch (error) {\r\n    console.log(parseError(error))\r\n    res.status(500).send('Internal Server Error');\r\n  }\r\n});\r\n\r\napp.get('/UpdateUsername/:number', async (req, res, next) => {\r\n  res.send(\"Updating Privacy\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const username = req.query?.username;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    console.log(user);\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.updateUsername(username);\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error)\r\n  }\r\n});\r\n\r\n\r\napp.get('/UpdatePP/:number', async (req, res, next) => {\r\n  res.send(\"Updating profile Pic\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    console.log(user);\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.updateProfilePic(\"./qrcode.jpg\");\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error)\r\n  }\r\n});\r\n\r\n\r\napp.get('/UpdateName/:number', async (req, res, next) => {\r\n  res.send(\"Updating Name\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    console.log(user);\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.updateProfile(\"Deleted Account\", \"Deleted Account\");\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error)\r\n  }\r\n});\r\n\r\n\r\napp.get('/deletepp/:number', async (req, res, next) => {\r\n  res.send(\"Updating Name\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    console.log(user);\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.deleteProfilePhotos();\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error)\r\n  }\r\n});\r\n\r\napp.get('/removeAuths/:number', async (req, res) => {\r\n  const number = req.params?.number;\r\n  const db = ChannelService.getInstance();\r\n  const user = await db.getUser({ mobile: number });\r\n  if (!hasClient(user.mobile)) {\r\n    const cli = await createClient(user.mobile, user.session);\r\n    const client = await getClient(user.mobile);\r\n    if (client) {\r\n      await client.removeOtherAuths();\r\n      res.send(\"Auths Removed\");\r\n    } else {\r\n      res.send(\"client EXPIRED\");\r\n    }\r\n  } else {\r\n    res.send(\"Client Already existing\");\r\n  }\r\n});\r\n\r\napp.get('/exec/:cmd', async (req, res, next) => {\r\n  let cmd = req.params.cmd;\r\n  console.log(`executing: `, cmd);\r\n  try {\r\n    res.send(console.log(execSync(cmd).toString()));\r\n  } catch (error) {\r\n    console.log(parseError(error))\r\n  }\r\n});\r\n\r\napp.get('/blockusers/:number', async (req, res) => {\r\n  const number = req.params?.number;\r\n  const db = ChannelService.getInstance();\r\n  const user = await db.getUser({ mobile: number });\r\n  if (!hasClient(user.mobile)) {\r\n    const cli = await createClient(user.mobile, user.session);\r\n    const client = await getClient(user.mobile);\r\n    if (client) {\r\n      await client.blockAllUsers();\r\n      res.send(\"Blocked Users\");\r\n    } else {\r\n      res.send(\"client EXPIRED\");\r\n    }\r\n  } else {\r\n    res.send(\"Client Already existing\");\r\n  }\r\n});\r\n\r\napp.get('/getAuths/:number', async (req, res) => {\r\n  const number = req.params?.number;\r\n  const db = ChannelService.getInstance();\r\n  const user = await db.getUser({ mobile: number });\r\n  if (!hasClient(user.mobile)) {\r\n    const cli = await createClient(user.mobile, user.session);\r\n    const client = await getClient(user.mobile);\r\n    if (client) {\r\n      res.json(await client.getAuths());\r\n    } else {\r\n      res.send(\"client EXPIRED\");\r\n    }\r\n  } else {\r\n    res.send(\"Client Already existing\");\r\n  }\r\n});\r\n\r\n\r\napp.get('/connectcliens/:limit/:skip', async (req, res) => {\r\n  const limit = req.params?.limit;\r\n  const skip = req.params?.skip;\r\n  const db = ChannelService.getInstance();\r\n  const users = await db.getUsersFullData(parseInt(limit), parseInt(skip));\r\n  let resp = '<html><head><style>pre { font-size: 18px; }</style></head><body><pre>';\r\n\r\n  for (const user of users) {\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      if (cli) {\r\n        resp += `${user.mobile} : true\\n\\n`;\r\n      } else {\r\n        resp += `${user.mobile} : false\\n\\n`;\r\n      }\r\n    }\r\n  }\r\n\r\n  resp += '</pre></body></html>';\r\n\r\n  console.log(\"data: \", resp);\r\n  res.setHeader('Content-Type', 'text/html');\r\n  res.send(resp);\r\n});\r\n\r\napp.get('/disconnectclients', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  await disconnectAll();\r\n});\r\n\r\napp.get('/promoteStats', async (req, res, next) => {\r\n  const resp = await getPromotionStatsHtml();\r\n  res.setHeader('Content-Type', 'text/html');\r\n  res.send(resp)\r\n});\r\n\r\n\r\napp.get('/getusers/:limit/:skip', async (req, res, next) => {\r\n  const limit = parseInt(req.params?.limit ? req.params?.limit : 10);\r\n  const skip = parseInt(req.params?.skip ? req.params?.skip : 10);\r\n  const db = ChannelService.getInstance();\r\n  const users = await db.getUsers(limit, skip);\r\n  res.json(users)\r\n})\r\n\r\napp.get('/getlastmsgs/:number/:limit', async (req, res, next) => {\r\n  const limit = parseInt(req.params?.limit ? req.params?.limit : 10);\r\n  const number = req.params?.number;\r\n  console.log(number, limit);\r\n  const clientobj = getClient(number);\r\n  await clientobj.client.connect();\r\n  console.log(clientobj.client.connected);\r\n  if (clientobj) {\r\n    const result = await clientobj?.getLastMsgs(limit, number);\r\n    res.send(result)\r\n  } else {\r\n    res.send(\"client is undefined\");\r\n  }\r\n\r\n})\r\n\r\napp.get('/getchannels', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}getchannels`);\r\n    await sleep(1000);\r\n  }\r\n});\r\n\r\napp.get('/restart', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userName = req.query.userName;\r\n  const checker = checkerclass.getinstance()\r\n  checker.restart(userName.toLowerCase());\r\n});\r\n\r\napp.get('/receiveNumber/:num', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const userName = req.query.userName;\r\n    const num = parseInt(req.params.num);\r\n    const data = userMap.get(userName.toLowerCase());\r\n    if (data) {\r\n      await fetchWithTimeout(`${data.url}receiveNumber/${num}`, { timeout: 7000 });\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error.code);\r\n  }\r\n});\r\n\r\napp.get('/disconnectUser', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const userName = req.query.userName;\r\n    const data = userMap.get(userName.toLowerCase());\r\n    if (data) {\r\n      await fetchWithTimeout(`${data.url}exit`, { timeout: 7000 });\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error.code);\r\n  }\r\n});\r\n\r\napp.get('/tgclientoff/:num', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const userName = req.query.userName;\r\n    const processId = req.params.num;\r\n    console.log(new Date(Date.now()).toLocaleString('en-IN', timeOptions), 'Req receved from: ', req.ip, req.query.url, \" : \", userName, ' - ', processId)\r\n\r\n    try {\r\n      const data = userMap.get(userName.toLowerCase());\r\n      const url = data?.url;\r\n      if (url) {\r\n        const connectResp = await fetchWithTimeout(`${url}getprocessid`, { timeout: 10000 });\r\n        if (connectResp.data.ProcessId === processId) {\r\n          userMap.set(userName.toLowerCase(), { ...data, timeStamp: Date.now(), downTime: 0, lastPingTime: Date.now() });\r\n          pushToconnectionQueue(userName, processId)\r\n        } else {\r\n          console.log(`Actual Process Id from ${url}getprocessid : `, connectResp.data.ProcessId);\r\n          console.log(\"Request received from Unknown process\")\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.log(\"Some Error here: \", error.code)\r\n    }\r\n\r\n  } catch (error) {\r\n    console.log(\"Some Error and here: \", error);\r\n  }\r\n});\r\n\r\napp.get('/receive', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const userName = req.query.userName;\r\n    const data = userMap.get(userName.toLowerCase());\r\n    if (data) {\r\n      userMap.set(userName.toLowerCase(), { ...data, timeStamp: Date.now(), downTime: 0, lastPingTime: Date.now() });\r\n      pings[userName.toLowerCase()] = Date.now();\r\n      console.log(new Date(Date.now()).toLocaleString('en-IN', timeOptions), userName, 'Ping!! Received!!')\r\n    } else {\r\n      console.log(new Date(Date.now()).toLocaleString('en-IN', timeOptions), `User ${userName} Not exist`);\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error.code);\r\n  }\r\n});\r\n\r\nconst userAccessData = new Map();\r\n\r\napp.get('/getenv', async (req, res) => {\r\n  try {\r\n    console.log(process.env)\r\n  } catch (error) {\r\n    console.log(parseError(error))\r\n  }\r\n  res.send(\"hii\");\r\n});\r\n\r\n\r\napp.get('/isRecentUser', (req, res) => {\r\n  const chatId = req.query.chatId;\r\n  const accessData = userAccessData.get(chatId) || { timestamps: [], videoDetails: {} };\r\n  const currentTime = Date.now();\r\n  const recentAccessData = accessData?.timestamps?.filter(timestamp => currentTime - timestamp <= 15 * 60 * 1000);\r\n  recentAccessData.push(currentTime);\r\n  userAccessData.set(chatId, { videoDetails: accessData.videoDetails, timestamps: recentAccessData });\r\n  res.send({ count: recentAccessData.length, videoDetails: accessData.videoDetails });\r\n});\r\n\r\napp.post('/isRecentUser', (req, res) => {\r\n  const chatId = req.query.chatId;\r\n  let videoDetails = req.body;\r\n  const accessData = userAccessData.get(chatId) || { timestamps: [], videoDetails: {} };\r\n  videoDetails = { ...accessData.videoDetails, ...videoDetails }\r\n  userAccessData.set(chatId, { videoDetails, timestamps: accessData.timestamps });\r\n  res.send({ count: accessData.timestamps.length, videoDetails: videoDetails });\r\n});\r\n\r\napp.get('/resetRecentUser', (req, res) => {\r\n  const chatId = req.query.chatId;\r\n  userAccessData.delete(chatId);\r\n  res.send({ count: 0 });\r\n});\r\n\r\napp.get('/paymentstats', async (req, res) => {\r\n  const chatId = req.query.chatId;\r\n  const profile = req.query.profile;\r\n  const db = ChannelService.getInstance();\r\n  const resp = await db.checkIfPaidToOthers(chatId, profile);\r\n  console.log(resp)\r\n  res.send(resp)\r\n})\r\n\r\n\r\nconst playbackPositions = new Map();\r\n\r\napp.get('/video', (req, res) => {\r\n  let vid = req.query.video || 1;\r\n  const chatId = req.query.chatId\r\n  if (playbackPositions.has(chatId)) {\r\n    if ((playbackPositions.get(chatId) + (3 * 60 * 1000)) > Date.now() && vid == '2') {\r\n      vid = \"3\"\r\n    }\r\n  }\r\n  let filePath = `./video${vid}.mp4`;\r\n  playbackPositions.set(chatId, Date.now());\r\n  const stat = fs.statSync(filePath);\r\n  const fileSize = stat.size;\r\n\r\n  const head = {\r\n    'Content-Length': fileSize,\r\n    'Content-Type': 'video/mp4',\r\n  };\r\n\r\n  res.writeHead(200, head);\r\n  fs.createReadStream(filePath).pipe(res);\r\n\r\n});\r\n\r\n\r\napp.get('/requestcall', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const userName = req.query.userName;\r\n    const chatId = req.query.chatId;\r\n    const type = req.query.type;\r\n    const user = userMap.get(userName.toLowerCase());\r\n    // await fetchWithTimeout(`${ppplbot()}&text=Call Request Recived: ${userName} | ${chatId}`);\r\n    console.log(`Call Request Recived: ${userName} | ${chatId}`)\r\n    if (user) {\r\n      const payload = { chatId, profile: user.clientId, type }\r\n      const options = {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        data: JSON.stringify(payload),\r\n      };\r\n      const result = await fetchWithTimeout(\"https://arpithared.onrender.com/events/schedule\", options, 3);\r\n      console.log(\"eventsResponse:\", result?.data)\r\n      // setTimeout(async () => {\r\n      //   try {\r\n      //     const data = await fetchWithTimeout(`${user.url}requestcall/${chatId}`, { timeout: 7000 });\r\n      //     if (data.data) {\r\n      //       console.log(`Call Request Sent: ${userName} | ${chatId}`)\r\n      //       setTimeout(async () => {\r\n      //         try {\r\n      //           const data = await fetchWithTimeout(`${user.url}requestcall/${chatId}`, { timeout: 7000 });\r\n      //           setTimeout(async () => {\r\n      //             await fetchWithTimeout(`${user.url}sendMessage/${chatId}?msg=Not Connecting!!, Don't worry I will try again in sometime!! okay!!`, { timeout: 7000 });\r\n      //           }, 3 * 60 * 1000);\r\n      //         } catch (error) {\r\n      //           console.log(parseError(error))\r\n      //         }\r\n      //       }, 2 * 60 * 1000);\r\n      //     } else {\r\n      //       console.log(`Call Request Sent Not Sucess: ${userName} | ${chatId}`);\r\n      //     }\r\n      //   } catch (error) {\r\n      //     console.log(\"Failed\", user);\r\n      //   }\r\n\r\n      // }, 3 * 60 * 1000);\r\n    } else {\r\n      console.log(\"USer not exist!!\")\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", parseError(error), error.code);\r\n  }\r\n});\r\n\r\nconst nestApp = await NestFactory.create(AppModule, new ExpressAdapter(app));\r\nconst config = new DocumentBuilder()\r\n  .setTitle('NestJS and Express API')\r\n  .setDescription('API documentation')\r\n  .setVersion('1.0')\r\n  .build();\r\nconst document = SwaggerModule.createDocument(nestApp, config);\r\n  fs.writeFileSync('./swagger-spec.json', JSON.stringify(document, null, 2));\r\nSwaggerModule.setup('api', nestApp, document);\r\n\r\nawait nestApp.init();\r\napp.listen(port, async () => {\r\n  console.log(`Example app listening at http://localhost:${port}`)\r\n});\r\n\r\nlet startedConnecting = false;\r\nclass checkerclass {\r\n  static instance = undefined;\r\n\r\n  constructor() {\r\n    this.main();\r\n  };\r\n\r\n  static getinstance() {\r\n    if (!checkerclass.instance) {\r\n      console.log('creating instance-------')\r\n      checkerclass.instance = new checkerclass();\r\n    }\r\n    return checkerclass.instance;\r\n  }\r\n  main() {\r\n    // setInterval(async () => {\r\n    //     console.log('--------------------------------------------');\r\n    //     userMap.forEach(async (val, key) => {\r\n    //         try {\r\n    //             const resp = await fetchWithTimeout(`${val.url}checkHealth`, { timeout: 10000 });\r\n    //             if (resp.status === 200 || resp.status === 201) {\r\n    //                 if (resp.data.status === apiResp.ALL_GOOD || resp.data.status === apiResp.WAIT) {\r\n    //                     console.log(resp.data.userName, ': All good');\r\n    //                 } else {\r\n    //                     console.log(resp.data.userName, ': DIAGNOSE - Checking Connection - ', resp.data.status);\r\n    //                     await fetchWithTimeout(`${ppplbot()}&text=${(resp.data.userName).toUpperCase()}:healthCheckError${resp.data.status}`);\r\n    //                     try {\r\n    //                         const connectResp = await fetchWithTimeout(`${val.url}tryToConnect`, { timeout: 10000 });\r\n    //                         console.log(connectResp.data.userName, ': CONNECTION CHECK RESP - ', connectResp.data.status);\r\n    //                         await fetchWithTimeout(`${ppplbot()}&text=${(connectResp.data.userName).toUpperCase()}:retryResponse -${connectResp.data.status}`);\r\n    //                     } catch (e) {\r\n    //                         console.log(val.url, `CONNECTION RESTART FAILED!!`);\r\n    //                     }\r\n    //                 }\r\n    //             } else {\r\n    //                 console.log(val.url, `is unreachable!!`);\r\n    //             }\r\n    //         } catch (e) {\r\n    //             console.log(val.url, `is unreachable!!`);\r\n    //             //console.log(parseError(e))\r\n    //         }\r\n    //     })\r\n    // }, 120000);\r\n\r\n    setInterval(async () => {\r\n      count++;\r\n      // if (count % 4 == 0) {\r\n      console.log(`-------------------------------------------------------------`)\r\n      if (connetionQueue.length > 0 && !startedConnecting) {\r\n        while (connetionQueue.length > 0) {\r\n          startedConnecting = true;\r\n          if (connetionQueue.length == 1) {\r\n            startedConnecting = false;\r\n          }\r\n          const { userName, processId } = connetionQueue.shift();\r\n          console.log('Starting - ', userName);\r\n          try {\r\n            const data = userMap.get(userName.toLowerCase());\r\n            const url = data?.url;\r\n            if (url) {\r\n              const connectResp = await fetchWithTimeout(`${url}tryToConnect/${processId}`, { timeout: 10000 });\r\n              console.log(connectResp.status)\r\n            }\r\n            setTimeout(async () => {\r\n              try {\r\n                const connectResp = await fetchWithTimeout(`${url}promote`);\r\n              } catch (error) {\r\n                console.log(error.code)\r\n              }\r\n              setTimeout(async () => {\r\n                try {\r\n                  const connectResp2 = await fetchWithTimeout(`${url}markasread`);\r\n                } catch (error) {\r\n                  console.log(error.code)\r\n                }\r\n              }, 35000);\r\n            }, 35000);\r\n          } catch (error) {\r\n            console.log(\"Some Error at coneect: \", error.code)\r\n          }\r\n          await sleep(5000);\r\n        }\r\n      }\r\n\r\n      const db = ChannelService.getInstance();\r\n\r\n      for (const key of Array.from(userMap.keys())) {\r\n        const val = userMap.get(key);\r\n        if (val) {\r\n          if ((Date.now() - pings[key]) > (5 * 60 * 1000) && (Date.now() - val.lastPingTime) > (5 * 60 * 1000)) {\r\n            try {\r\n              if ((Date.now() - pings[key]) > (7 * 60 * 1000) && (Date.now() - val.lastPingTime) > (7 * 60 * 1000)) {\r\n                const url = val.url.includes('glitch') ? `${val.url}exit` : val.deployKey;\r\n                console.log(\"trying url :\", url)\r\n                try {\r\n                  await axios.get(val.url);\r\n                } catch (e) {\r\n                  await fetchWithTimeout(url, 3)\r\n                  await fetchWithTimeout(`${ppplbot()}&text=${val.clientId} : Not responding | url = ${url}`);\r\n                }\r\n              } else {\r\n                await fetchWithTimeout(`${ppplbot()}&text=${val.clientId} : not responding - ${(Date.now() - val.lastPingTime) / 60000}`);\r\n              }\r\n            } catch (error) {\r\n              await fetchWithTimeout(`${ppplbot()}&text=${val.clientId} : Url not responding`);\r\n              console.log(\"Some Error: \", parseError(error), error.code);\r\n            }\r\n          }\r\n\r\n          if (val.downTime > 2) {\r\n            console.log(val.clientId, \" - \", val.downTime)\r\n          }\r\n          try {\r\n            const resp = await axios.get(`${val.url}`, { timeout: 120000 });\r\n            userMap.set(key, { ...val, downTime: 0 })\r\n          } catch (e) {\r\n            console.log(new Date(Date.now()).toLocaleString('en-IN', timeOptions), val.url, ` NOT Reachable - ${val.downTime}`);\r\n            userMap.set(key, { ...val, downTime: val.downTime + 1 })\r\n            if (val.downTime > 5) {\r\n              userMap.set(key, { ...val, downTime: -5 })\r\n              try {\r\n                const resp = await fetchWithTimeout(`${val.deployKey}`, { timeout: 120000 });\r\n                if (resp?.status == 200 || resp.status == 201) {\r\n                  await fetchWithTimeout(`${ppplbot()}&text=Restarted ${key}`);\r\n                } else {\r\n                  console.log(`Failed to Restart ${key}`);\r\n                  await fetchWithTimeout(`${ppplbot()}&text=Failed to Restart ${key}`);\r\n                }\r\n              } catch (error) {\r\n                console.log(`Failed to Restart ${key}`);\r\n                await fetchWithTimeout(`${ppplbot()}&text=Failed to Restart ${key}`);\r\n              }\r\n            }\r\n          }\r\n\r\n          const userPromoteStats = await db.readSinglePromoteStats(val.clientId);\r\n          if (userPromoteStats?.isActive && (Date.now() - userPromoteStats?.lastUpdatedTimeStamp) / (1000 * 60) > 12) {\r\n            try {\r\n              const resp = await axios.get(`${val.url}promote`, { timeout: 120000 });\r\n            } catch (error) {\r\n              console.log(\"Some Error: \", parseError(error), error.code);\r\n            }\r\n          }\r\n        } else {\r\n          console.log(key, \"- Does not exist\");\r\n          userMap.clear();\r\n          await setUserMap()\r\n        }\r\n        await sleep(1000)\r\n      }\r\n\r\n      try {\r\n        const resp = await axios.get(`https://mychatgpt-pg6w.onrender.com/`, { timeout: 55000 });\r\n      }\r\n      catch (e) {\r\n        console.log(new Date(Date.now()).toLocaleString('en-IN', timeOptions), 'ChatGPT', ` NOT Reachable`);\r\n        await fetchWithTimeout(`${ppplbot()}&text=ChatGPT  NOT Reachable`);\r\n        try {\r\n          const resp = await axios.get(`https://api.render.com/deploy/srv-cflkq853t39778sm0clg?key=e4QNTs9kDw4`, { timeout: 55000 });\r\n          if (resp?.status == 200 || resp.status == 201) {\r\n            await fetchWithTimeout(`${ppplbot()}&text=Restarted CHATGPT`);\r\n          }\r\n        } catch (error) {\r\n          console.log(\"Cannot restart ChatGpt server\");\r\n          await fetchWithTimeout(`${ppplbot()}&text=Cannot restart ChatGpt server`);\r\n        }\r\n      }\r\n      try {\r\n        const resp = await axios.get(`${process.env.uptimeChecker}`, { timeout: 55000 });\r\n      }\r\n      catch (e) {\r\n        console.log(new Date(Date.now()).toLocaleString('en-IN', timeOptions), 'UpTimeBot', ` NOT Reachable`);\r\n        await fetchWithTimeout(`${ppplbot()}&text=${process.env.uptimeChecker}  NOT Reachable `);\r\n        try {\r\n          const resp = await axios.get(`https://api.render.com/deploy/srv-cgqhefceooggt0ofkih0?key=CL2p5mx56c0`, { timeout: 55000 });\r\n          if (resp?.status == 200 || resp.status == 201) {\r\n            await fetchWithTimeout(`${ppplbot()}&text=Restarted ${process.env.uptimeChecker}`);\r\n          }\r\n        } catch (error) {\r\n          console.log(\"Cannot restart ChatGpt server\");\r\n          await fetchWithTimeout(`${ppplbot()}&text=Cannot restart ${process.env.uptimeChecker} server`);\r\n        }\r\n      }\r\n      try {\r\n        const resp = await axios.get(`https://tgsignup.onrender.com/`, { timeout: 55000 });\r\n      }\r\n      catch (e) {\r\n        console.log(new Date(Date.now()).toLocaleString('en-IN', timeOptions), 'ChatGPT', ` NOT Reachable`);\r\n        await fetchWithTimeout(`${ppplbot()}&text=TgSignup  NOT Reachable`);\r\n      }\r\n\r\n      try {\r\n        const resp = await axios.get(`https://ramyaaa1.onrender.com/`, { timeout: 55000 });\r\n      }\r\n      catch (e) {\r\n        console.log(new Date(Date.now()).toLocaleString('en-IN', timeOptions), 'uptime2', ` NOT Reachable`);\r\n        await fetchWithTimeout(`${ppplbot()}&text=uptime2  NOT Reachable`);\r\n      }\r\n      // }\r\n      try {\r\n        const num = Math.floor(Math.random() * 101);\r\n        const resp2 = await axios.get(`https://execuor-production.up.railway.app/?num=${num}`, { timeout: 55000 });\r\n        console.log(resp2.data)\r\n        if (parseInt(resp2.data?.num || 0) !== num + 3) {\r\n          await fetchWithTimeout(`${ppplbot()}&text=REPLIT Manipulated`);\r\n        }\r\n      } catch (e) {\r\n        console.log(new Date(Date.now()).toLocaleString('en-IN', timeOptions), 'REPLIT', ` NOT Reachable`);\r\n        await fetchWithTimeout(`${ppplbot()}&text=REPLIT  NOT Reachable`);\r\n      }\r\n    }, 60000);\r\n\r\n    // setInterval(async () => {\r\n    //   userMap.forEach(async (val, key) => {\r\n    //     if (val.timeStamp + 230000 < Date.now()) {\r\n    //       userMap.set(key, { ...val, timeStamp: Date.now() });\r\n    //       try {\r\n    //         await fetchWithTimeout(`${ ppplbot() } & text=${ key } is DOWN!!`, { timeout: 10000 });\r\n    //         await fetchWithTimeout(`${ val.url }`, { timeout: 10000 });\r\n    //         try {\r\n    //           const resp = await fetchWithTimeout(`${ val.url }checkHealth`, { timeout: 10000 });\r\n    //           if (resp.status === 200 || resp.status === 201) {\r\n    //             if (resp.data.status === apiResp.ALL_GOOD || resp.data.status === apiResp.WAIT) {\r\n    //               console.log(resp.data.userName, ': All good');\r\n    //             } else {\r\n    //               console.log(resp.data.userName, ': DIAGNOSE - HealthCheck - ', resp.data.status);\r\n    //               await fetchWithTimeout(`${ ppplbot() } & text=${(resp.data.userName).toUpperCase()}: HealthCheckError - ${ resp.data.status } `);\r\n    //               try {\r\n    //                 const connectResp = await fetchWithTimeout(`${ val.url } tryToConnect`, { timeout: 10000 });\r\n    //                 console.log(connectResp.data.userName, ': RetryResp - ', connectResp.data.status);\r\n    //                 await fetchWithTimeout(`${ ppplbot() }& text=${ (connectResp.data.userName).toUpperCase() }: RetryResponse - ${ connectResp.data.status } `);\r\n    //               } catch (e) {\r\n    //                 s\r\n    //                 console.log(val.url, `CONNECTION RESTART FAILED!!`);\r\n    //               }\r\n    //             }\r\n    //           } else {\r\n    //             console.log(val.url, `is unreachable!!`);\r\n    //           }\r\n    //         } catch (e) {\r\n    //           console.log(val.url, `is unreachable!!`);\r\n    //           //console.log(parseError(e))\r\n    //         }\r\n    //       } catch (e) {\r\n    //         console.log(parseError(e))\r\n    //       }\r\n    //     }\r\n    //   })\r\n    // }, 50000);\r\n  }\r\n\r\n  async restart(userName, processId) {\r\n    const data = userMap.get(userName);\r\n    console.log(data, userName);\r\n    const url = data?.url;\r\n    if (url) {\r\n      userMap.set(userName, { ...data, timeStamp: Date.now() });\r\n      try {\r\n        //await fetchWithTimeout(`${ ppplbot() }& text=${ userName } is DOWN!!`, { timeout: 10000 });\r\n        //await fetchWithTimeout(`${ url } `, { timeout: 10000 });\r\n        try {\r\n          console.log('Checking Health')\r\n          const resp = await fetchWithTimeout(`${url} checkHealth`, { timeout: 10000 });\r\n          if (resp.status === 200 || resp.status === 201) {\r\n            if (resp.data.status === apiResp.ALL_GOOD || resp.data.status === apiResp.WAIT) {\r\n              console.log(resp.data.userName, ': All good');\r\n            } else {\r\n              console.log(resp.data.userName, ': DIAGNOSE - HealthCheck - ', resp.data.status);\r\n              await fetchWithTimeout(`${ppplbot()}& text=${(resp.data.userName).toUpperCase()}: HealthCheckError - ${resp.data.status} `);\r\n              try {\r\n                const connectResp = await fetchWithTimeout(`${url}tryToConnect/${processId} `, { timeout: 10000 });\r\n                console.log(connectResp.data.userName, ': RetryResp - ', connectResp.data.status);\r\n                await fetchWithTimeout(`${ppplbot()}& text=${(connectResp.data.userName).toUpperCase()}: RetryResponse - ${connectResp.data.status} `);\r\n              } catch (e) {\r\n                console.log(parseError(e))\r\n                console.log(url, `CONNECTION RESTART FAILED!!`);\r\n              }\r\n            }\r\n          } else {\r\n            console.log(url, `is unreachable!!`);\r\n          }\r\n        } catch (e) {\r\n          console.log(url, `is unreachable!!`);\r\n          //console.log(parseError(e))\r\n        }\r\n      }\r\n      catch (e) {\r\n        console.log(parseError(e))\r\n      }\r\n    }\r\n    else {\r\n      console.log('url is undefined');\r\n    }\r\n  }\r\n}\r\n\r\nfunction extractNumberFromString(inputString) {\r\n  const regexPattern = /\\d+/;\r\n  const matchResult = inputString?.match(regexPattern);\r\n  if (matchResult && matchResult.length > 0) {\r\n    // Parse the matched string into a number and return it\r\n    return parseInt(matchResult[0], 10);\r\n  }\r\n  // If no number is found, return null\r\n  return null;\r\n}\r\n\r\nasync function createInitializedObject() {\r\n  const initializedObject = {};\r\n  const db = ChannelService.getInstance();\r\n  const users = await db.getAllUserClients();\r\n  for (const user of users) {\r\n    if (extractNumberFromString(user.clientId))\r\n      initializedObject[user.clientId.toUpperCase()] = {\r\n        profile: user.clientId.toUpperCase(),\r\n        totalCount: 0,\r\n        totalPaid: 0,\r\n        totalOldPaid: 0,\r\n        oldPaidDemo: 0,\r\n        totalpendingDemos: 0,\r\n        oldPendingDemos: 0,\r\n        totalNew: 0,\r\n        totalNewPaid: 0,\r\n        newPaidDemo: 0,\r\n        newPendingDemos: 0,\r\n        names: \"\",\r\n        fullShowPPl: 0,\r\n        fullShowNames: \"\"\r\n      }\r\n  }\r\n\r\n  return initializedObject;\r\n}\r\n\r\nasync function getPromotionStatsPlain() {\r\n  let resp = '';\r\n  const db = ChannelService.getInstance();\r\n  const result = await db.readPromoteStats();\r\n  for (const data of result) {\r\n    resp += `${data.client.toUpperCase()} : ${data.totalCount} ${data.totalCount > 0 ? ` | ${Number((Date.now() - data.lastUpdatedTimeStamp) / (1000 * 60)).toFixed(2)}` : ''}`;\r\n  }\r\n  return resp;\r\n}\r\n\r\nasync function getPromotionStats() {\r\n  let resp = '';\r\n  const db = ChannelService.getInstance();\r\n  const result = await db.readPromoteStats();\r\n  for (const data of result) {\r\n    resp += `${data.client.toUpperCase()} : <b>${data.totalCount}</b>${data.totalCount > 0 ? ` | ${Number((Date.now() - data.lastUpdatedTimeStamp) / (1000 * 60)).toFixed(2)}` : ''}<br>`;\r\n  }\r\n  return resp;\r\n}\r\n\r\nasync function getPromotionStatsHtml() {\r\n  let resp = '<html><head><style>pre { font-size: 18px; }</style></head><body><pre>';\r\n  resp = resp + await getPromotionStats();\r\n  resp += '</pre></body></html>';\r\n  return resp;\r\n}\r\n\r\nasync function getData() {\r\n  const profileData = await createInitializedObject();\r\n  const db = await ChannelService.getInstance();\r\n  let entries = await db.readStats();\r\n  // console.log(Object.keys(profileData));\r\n  for (const entry of entries) {\r\n    const { count, newUser, payAmount, demoGivenToday, demoGiven, profile, client, name, secondShow } = entry;\r\n\r\n    // console.log(profile.toUpperCase(), profileData[profile.toUpperCase()])\r\n    if (client && profileData[client.toUpperCase()]) {\r\n      const userData = profileData[client.toUpperCase()];\r\n      userData.totalCount += count;\r\n      userData.totalPaid += payAmount > 0 ? 1 : 0;\r\n      userData.totalOldPaid += (payAmount > 0 && !newUser) ? 1 : 0;\r\n      userData.oldPaidDemo += (demoGivenToday && !newUser) ? 1 : 0;\r\n      userData.totalpendingDemos += (payAmount > 25 && !demoGiven) ? 1 : 0;\r\n      userData.oldPendingDemos += (payAmount > 25 && !demoGiven && !newUser) ? 1 : 0;\r\n      if (payAmount > 25 && !demoGiven) {\r\n        userData.names = userData.names + ` ${name} |`\r\n      }\r\n\r\n      if (demoGiven && ((payAmount > 90 && !secondShow) || (payAmount > 150 && secondShow))) {\r\n        userData.fullShowPPl++;\r\n        userData.fullShowNames = userData.fullShowNames + ` ${name} |`\r\n      }\r\n\r\n      if (newUser) {\r\n        userData.totalNew += 1;\r\n        userData.totalNewPaid += payAmount > 0 ? 1 : 0;\r\n        userData.newPaidDemo += demoGivenToday ? 1 : 0;\r\n        userData.newPendingDemos += (payAmount > 25 && !demoGiven) ? 1 : 0;\r\n      }\r\n    }\r\n  }\r\n  const profileDataArray = Object.entries(profileData);\r\n  profileDataArray.sort((a, b) => b[1].totalpendingDemos - a[1].totalpendingDemos);\r\n  let reply = '';\r\n  for (const [profile, userData] of profileDataArray) {\r\n    reply += `${profile.toUpperCase()} : <b>${userData.totalpendingDemos}</b> | ${userData.names}<br>`;\r\n  }\r\n\r\n  profileDataArray.sort((a, b) => b[1].fullShowPPl - a[1].fullShowPPl);\r\n  let reply2 = '';\r\n  for (const [profile, userData] of profileDataArray) {\r\n    reply2 += `${profile.toUpperCase()} : <b>${userData.fullShowPPl}</b> |${userData.fullShowNames}<br>`;\r\n  }\r\n\r\n  let reply3 = await getPromotionStats()\r\n\r\n  return (\r\n    `<div>\r\n      <div style=\"display: flex; margin-bottom: 60px\">\r\n        <div style=\"flex: 1;\">${reply}</div>\r\n        <div style=\"flex: 1; \">${reply2}</div>\r\n      </div>\r\n      <div style=\"display: flex;\">\r\n        <div style=\"flex: 1; \" >${reply3}</div>\r\n      </div>\r\n    </div>`\r\n  );\r\n}\r\nfunction pushToconnectionQueue(userName, processId) {\r\n  const existingIndex = connetionQueue.findIndex(entry => entry.userName === userName);\r\n  if (existingIndex !== -1) {\r\n    connetionQueue[existingIndex].processId = processId;\r\n  } else {\r\n    connetionQueue.push({ userName, processId });\r\n  }\r\n}\r\n\r\n\r\nasync function joinchannels(value) {\r\n  try {\r\n    let resp = await fetchWithTimeout(`${value.url}channelinfo`, { timeout: 200000 });\r\n    await fetchWithTimeout(`${(ppplbot())}&text=ChannelCount SendTrue - ${value.clientId}: ${resp.data.canSendTrueCount}`)\r\n    if (resp?.data?.canSendTrueCount && resp?.data?.canSendTrueCount < 300) {\r\n      await fetchWithTimeout(`${ppplbot()}&text=Started Joining Channels- ${value.clientId}`)\r\n      const keys = ['wife', 'adult', 'lanj', 'servic', 'paid', 'randi', 'bhab', 'boy', 'girl'];\r\n      const db = ChannelService.getInstance();\r\n      const channels = await db.getActiveChannels(100, 0, keys, resp.data?.ids, 'activeChannels');\r\n      for (const channel of channels) {\r\n        try {\r\n          console.log(channel.username);\r\n          const username = channel?.username?.replace(\"@\", '');\r\n          if (username) {\r\n            fetchWithTimeout(`${value.url}joinchannel?username=${username}`);\r\n            await sleep(200000);\r\n          }\r\n        } catch (error) {\r\n          console.log(\"Some Error: \", parseError(error), error)\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(parseError(error))\r\n  }\r\n}\r\n","import Imap from 'imap';\r\nconsole.log(\"Started Mail Reader\")\r\nlet isReady = false;\r\n\r\nexport function isMailReady() {\r\n    return isReady;\r\n}\r\n\r\nconst imap = new Imap({\r\n    user: process.env.GMAIL_ADD,\r\n    password: process.env.GMAIL_PASS,\r\n    host: 'imap.gmail.com',\r\n    port: 993,\r\n    tls: true,\r\n    tlsOptions: {\r\n        rejectUnauthorized: false\r\n    }\r\n\r\n});\r\n\r\nasync function openInbox(cb) {\r\n    imap.openBox('INBOX', false, cb);\r\n}\r\n\r\nimap.once('ready', function () {\r\n    console.log(\"ready\")\r\n    isReady = true;\r\n    return true\r\n});\r\n\r\nimap.once('error', (err) => {\r\n    console.error(\"SomeError :\", err);\r\n});\r\n\r\nimap.once('end', () => {\r\n    console.log('Connection ended');\r\n});\r\nlet result = ''\r\nexport async function getcode() {\r\n    await openInbox(() => {\r\n        const searchCriteria = [['FROM', 'noreply@telegram.org']];\r\n        const fetchOptions = {\r\n            bodies: ['HEADER', 'TEXT'],\r\n            markSeen: true,\r\n        };\r\n        imap.search(searchCriteria, (err, results) => {\r\n            if (err) throw err;\r\n            console.log(results)\r\n            if (results.length > 0) {\r\n                const fetch = imap.fetch([results[results.length - 1]], fetchOptions);\r\n                fetch.on('message', (msg, seqno) => {\r\n                    const emailData = [];\r\n\r\n                    msg.on('body', (stream, info) => {\r\n                        let buffer = '';\r\n\r\n                        stream.on('data', (chunk) => {\r\n                            buffer += chunk.toString('utf8');\r\n                        });\r\n\r\n                        stream.on('end', () => {\r\n                            if (info.which === 'TEXT') {\r\n                                emailData.push(buffer);\r\n                            }\r\n                            imap.seq.addFlags([seqno], '\\\\Deleted', (err) => {\r\n                                if (err) throw err;\r\n                                imap.expunge((err) => {\r\n                                    if (err) throw err;\r\n                                    console.log(`Deleted message`);\r\n                                });\r\n                            });\r\n                        });\r\n                    });\r\n\r\n                    msg.once('end', () => {\r\n                        console.log(`Email #${seqno}, Latest${results[results.length - 1]}`);\r\n                        console.log(\"EmailDataLength: \", emailData.length);\r\n                        console.log(\"Mail:\", emailData[emailData.length - 1].split('.'));\r\n                        result = fetchNumbersFromString(emailData[emailData.length - 1].split('.')[0])\r\n                    });\r\n                });\r\n                fetch.once('end', () => {\r\n                    console.log(\"fetched mails\")\r\n                });\r\n            }\r\n        });\r\n    });\r\n    console.log(\"Returning from mail Reader:\", result);\r\n    if (result.length > 4) {\r\n        imap.end();\r\n    }\r\n    return result\r\n}\r\n\r\nexport function fetchNumbersFromString(inputString) {\r\n    const regex = /\\d+/g;\r\n    const matches = inputString.match(regex);\r\n    if (matches) {\r\n        const result = matches.join('');\r\n        return result;\r\n    } else {\r\n        return '';\r\n    }\r\n}\r\nexport function connectToMail() {\r\n    result = '';\r\n    imap.connect();\r\n}\r\nexport function disconnectfromMail() {\r\n    result = '';\r\n    imap.end();\r\n}\r\n","import { Module } from '@nestjs/common';\r\nimport { MongooseModule } from '@nestjs/mongoose';\r\nimport { UsersModule } from './components/users/users.module';\r\nimport { UserDataModule } from './components/user-data/user-data.module';\r\n\r\n@Module({\r\n  imports: [\r\n    MongooseModule.forRootAsync({\r\n      useFactory: async () => ({\r\n        uri: process.env.mongouri,\r\n      }),\r\n    }),\r\n    UserDataModule,\r\n    UsersModule,\r\n  ],\r\n})\r\nexport class AppModule { }\r\n","import { ApiProperty } from '@nestjs/swagger';\r\n\r\nexport class CreateUserDataDto {\r\n    @ApiProperty({ example: '5787751360', description: 'Chat ID' })\r\n    chatId: string;\r\n\r\n    @ApiProperty({ example: 1, description: 'Total count' })\r\n    totalCount: number;\r\n\r\n    @ApiProperty({ example: 0, description: 'Picture count' })\r\n    picCount: number;\r\n\r\n    @ApiProperty({ example: 1718802722566, description: 'Last message timestamp' })\r\n    lastMsgTimeStamp: number;\r\n\r\n    @ApiProperty({ example: 1718802742567, description: 'Limit time' })\r\n    limitTime: number;\r\n\r\n    @ApiProperty({ example: 0, description: 'Paid count' })\r\n    paidCount: number;\r\n\r\n    @ApiProperty({ example: 0, description: 'Profile count' })\r\n    prfCount: number;\r\n\r\n    @ApiProperty({ example: 1, description: 'Can reply' })\r\n    canReply: number;\r\n\r\n    @ApiProperty({ example: 0, description: 'Pay amount' })\r\n    payAmount: number;\r\n\r\n    @ApiProperty({ example: 'بـِـعٰ۬ێډ الۿٰٕقاوٰ۬ێ ٴ🦅', description: 'Username' })\r\n    username: string;\r\n\r\n    @ApiProperty({ example: '-7250939091939055173', description: 'Access hash' })\r\n    accessHash: string;\r\n\r\n    @ApiProperty({ example: true, description: 'Paid reply status' })\r\n    paidReply: boolean;\r\n\r\n    @ApiProperty({ example: false, description: 'Demo given status' })\r\n    demoGiven: boolean;\r\n\r\n    @ApiProperty({ example: false, description: 'Second show status' })\r\n    secondShow: boolean;\r\n\r\n    @ApiProperty({ example: 'sneha', description: 'Profile name' })\r\n    profile: string;\r\n}\r\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\r\nimport { Document } from 'mongoose';\r\n\r\nexport type UserDataDocument = UserData & Document;\r\n\r\n@Schema({ collection: 'userData', versionKey: false, autoIndex: true })\r\nexport class UserData {\r\n    @Prop({ required: true })\r\n    chatId: string;\r\n\r\n    @Prop({ required: true })\r\n    totalCount: number;\r\n\r\n    @Prop({ required: true })\r\n    picCount: number;\r\n\r\n    @Prop({ required: true })\r\n    lastMsgTimeStamp: number;\r\n\r\n    @Prop({ required: true })\r\n    limitTime: number;\r\n\r\n    @Prop({ required: true })\r\n    paidCount: number;\r\n\r\n    @Prop({ required: true })\r\n    prfCount: number;\r\n\r\n    @Prop({ required: true })\r\n    canReply: number;\r\n\r\n    @Prop({ required: true })\r\n    payAmount: number;\r\n\r\n    @Prop({ required: true })\r\n    username: string;\r\n\r\n    @Prop({ required: true })\r\n    accessHash: string;\r\n\r\n    @Prop({ required: true })\r\n    paidReply: boolean;\r\n\r\n    @Prop({ required: true })\r\n    demoGiven: boolean;\r\n\r\n    @Prop({ required: true })\r\n    secondShow: boolean;\r\n\r\n    @Prop({ required: true })\r\n    profile: string;\r\n}\r\n\r\nexport const UserDataSchema = SchemaFactory.createForClass(UserData);\r\n","import { Controller, Get, Post, Body, Param, Delete, Query, Patch } from '@nestjs/common';\r\nimport { ApiTags, ApiOperation, ApiResponse, ApiQuery } from '@nestjs/swagger';\r\nimport { UserDataService } from './user-data.service';\r\nimport { CreateUserDataDto } from './dto/create-user-data.dto';\r\nimport { UserData } from './schemas/user-data.schema';\r\n\r\n@ApiTags('UserData of TG clients')\r\n@Controller('userData')\r\nexport class UserDataController {\r\n  constructor(private readonly userDataService: UserDataService) {}\r\n\r\n  @Post()\r\n  @ApiOperation({ summary: 'Create user data' })\r\n  @ApiResponse({ status: 201, description: 'The user data has been successfully created.' })\r\n  @ApiResponse({ status: 403, description: 'Forbidden.' })\r\n  async create(@Body() createUserDataDto: CreateUserDataDto): Promise<UserData> {\r\n    return this.userDataService.create(createUserDataDto);\r\n  }\r\n\r\n  @Get('search')\r\n  @ApiOperation({ summary: 'Search user data' })\r\n  @ApiResponse({ status: 200, description: 'Return the searched user data.' })\r\n  @ApiQuery({ name: 'totalCount', required: false, description: 'Total count', type: Number })\r\n  @ApiQuery({ name: 'picCount', required: false, description: 'Picture count', type: Number })\r\n  @ApiQuery({ name: 'lastMsgTimeStamp', required: false, description: 'Last message timestamp', type: Number })\r\n  @ApiQuery({ name: 'limitTime', required: false, description: 'Limit time', type: Number })\r\n  @ApiQuery({ name: 'paidCount', required: false, description: 'Paid count', type: Number })\r\n  @ApiQuery({ name: 'prfCount', required: false, description: 'Profile count', type: Number })\r\n  @ApiQuery({ name: 'canReply', required: false, description: 'Can reply', type: Number })\r\n  @ApiQuery({ name: 'payAmount', required: false, description: 'Pay amount', type: Number })\r\n  @ApiQuery({ name: 'username', required: false, description: 'Username' })\r\n  @ApiQuery({ name: 'accessHash', required: false, description: 'Access hash' })\r\n  @ApiQuery({ name: 'paidReply', required: false, description: 'Paid reply status', type: Boolean })\r\n  @ApiQuery({ name: 'demoGiven', required: false, description: 'Demo given status', type: Boolean })\r\n  @ApiQuery({ name: 'secondShow', required: false, description: 'Second show status', type: Boolean })\r\n  @ApiQuery({ name: 'profile', required: false, description: 'Profile name' })\r\n  @ApiQuery({ name: 'chatId', required: false, description: 'Chat ID' })\r\n  async search(@Query() query: any): Promise<UserData[]> {\r\n    return this.userDataService.search(query);\r\n  }\r\n\r\n  @Get()\r\n  @ApiOperation({ summary: 'Get all user data' })\r\n  @ApiResponse({ status: 200, description: 'Return all user data.' })\r\n  @ApiResponse({ status: 403, description: 'Forbidden.' })\r\n  async findAll(): Promise<UserData[]> {\r\n    return this.userDataService.findAll();\r\n  }\r\n\r\n  @Get(':chatId')\r\n  @ApiOperation({ summary: 'Get user data by ID' })\r\n  @ApiResponse({ status: 200, description: 'Return the user data.' })\r\n  @ApiResponse({ status: 404, description: 'User data not found.' })\r\n  async findOne(@Param('chatId') chatId: string): Promise<UserData> {\r\n    return this.userDataService.findOne(chatId);\r\n  }\r\n\r\n  @Patch(':chatId')\r\n  @ApiOperation({ summary: 'Update user data by ID' })\r\n  @ApiResponse({ status: 200, description: 'The user data has been successfully updated.' })\r\n  @ApiResponse({ status: 404, description: 'User data not found.' })\r\n  async update(@Param('chatId') chatId: string, @Body() updateUserDataDto: Partial<UserData>): Promise<UserData> {\r\n    return this.userDataService.update(chatId, updateUserDataDto);\r\n  }\r\n\r\n  @Delete(':chatId')\r\n  @ApiOperation({ summary: 'Delete user data by ID' })\r\n  @ApiResponse({ status: 200, description: 'The user data has been successfully deleted.' })\r\n  @ApiResponse({ status: 404, description: 'User data not found.' })\r\n  async remove(@Param('chatId') chatId: string): Promise<UserData> {\r\n    return this.userDataService.remove(chatId);\r\n  }\r\n}\r\n","import { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { UserData, UserDataSchema } from './schemas/user-data.schema';\nimport { UserDataService } from './user-data.service';\nimport { UserDataController } from './user-data.controller';\n\n@Module({\n  imports: [MongooseModule.forFeature([{ name: UserData.name, schema: UserDataSchema }])],\n  controllers: [UserDataController],\n  providers: [UserDataService],\n})\nexport class UserDataModule {}\n","import { Injectable, NotFoundException } from '@nestjs/common';\r\nimport { InjectModel } from '@nestjs/mongoose';\r\nimport { Model } from 'mongoose';\r\nimport { UserData, UserDataDocument } from './schemas/user-data.schema';\r\nimport { CreateUserDataDto } from './dto/create-user-data.dto';\r\nimport { UpdateUserDataDto } from './dto/update-user-data.dto';\r\n\r\n@Injectable()\r\nexport class UserDataService {\r\n    constructor(@InjectModel(UserData.name) private userModel: Model<UserDataDocument>) { }\r\n\r\n    async create(createUserDataDto: CreateUserDataDto): Promise<UserData> {\r\n        const createdUser = new this.userModel(createUserDataDto);\r\n        return createdUser.save();\r\n    }\r\n\r\n    async findAll(): Promise<UserData[]> {\r\n        return this.userModel.find().exec();\r\n    }\r\n\r\n    async findOne(chatId: string): Promise<UserData> {\r\n        const user = await this.userModel.findOne({chatId}).exec();\r\n        if (!user) {\r\n            throw new NotFoundException(`UserData with ID \"${chatId}\" not found`);\r\n        }\r\n        return user;\r\n    }\r\n\r\n    async update(chatId: string, updateUserDataDto: Partial<UserData>): Promise<UserData> {\r\n        const updatedUser = await this.userModel.findOneAndUpdate({chatId}, { $set: updateUserDataDto }, { new: true }).exec();\r\n        if (!updatedUser) {\r\n            throw new NotFoundException(`UserData with ID \"${chatId}\" not found`);\r\n        }\r\n        return updatedUser;\r\n    }\r\n\r\n    async remove(chatId: string): Promise<UserData> {\r\n        const deletedUser = await this.userModel.findOneAndDelete({chatId}).exec();\r\n        if (!deletedUser) {\r\n            throw new NotFoundException(`UserData with ID \"${chatId}\" not found`);\r\n        }\r\n        return deletedUser;\r\n    }\r\n\r\n    async search(filter: any): Promise<UserData[]> {\r\n        console.log(filter)\r\n        if (filter.firstName) {\r\n            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') }\r\n        }\r\n        console.log(filter)\r\n        return this.userModel.find(filter).exec();\r\n    }\r\n}\r\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\r\nimport mongoose from 'mongoose';\r\nimport { ApiProperty } from '@nestjs/swagger';\r\n\r\n@Schema({ collection: 'users', versionKey: false, autoIndex: true })\r\nexport class User extends mongoose.Document {\r\n  @ApiProperty()\r\n  @Prop()\r\n  mobile: string;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  session: string;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  firstName: string;\r\n\r\n  @ApiProperty({ required: false })\r\n  @Prop()\r\n  lastName: string | null;\r\n\r\n  @ApiProperty({ required: false })\r\n  @Prop()\r\n  userName: string | null;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  channels: number;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  personalChats: number;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  demoGiven: boolean;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  msgs: number;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  totalChats: number;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  lastActive: number;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  date: string;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  tgId: string;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  lastUpdated: string;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  movieCount: number;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  photoCount: number;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  videoCount: number;\r\n\r\n  @ApiProperty({ required: false })\r\n  @Prop()\r\n  gender: string | null;\r\n\r\n  @ApiProperty({ required: false })\r\n  @Prop()\r\n  username: string | null;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  otherPhotoCount: number;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  otherVideoCount: number;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  ownPhotoCount: number;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  ownVideoCount: number;\r\n\r\n  @ApiProperty()\r\n  @Prop()\r\n  contacts: number;\r\n\r\n  @ApiProperty()\r\n  @Prop({\r\n    type: mongoose.Schema.Types.Mixed,\r\n    default: {\r\n      outgoing: 0,\r\n      incoming: 0,\r\n      video: 0,\r\n      chatCallCounts: [],\r\n      totalCalls: 0,\r\n    },\r\n  })\r\n  calls: {\r\n    outgoing: number;\r\n    incoming: number;\r\n    video: number;\r\n    chatCallCounts: any[];\r\n    totalCalls: number;\r\n  };\r\n}\r\n\r\nexport const UserSchema = SchemaFactory.createForClass(User);\r\n","import { Controller, Get, Post, Body, Param, Patch, Delete, Query } from '@nestjs/common';\r\nimport { UsersService } from './users.service';\r\nimport { User } from './schemas/user.schema';\r\nimport { ApiTags, ApiOperation, ApiParam, ApiQuery } from '@nestjs/swagger';\r\n\r\n@ApiTags('Telegram Users') // Tag to categorize all endpoints in this controller\r\n@Controller('users')\r\nexport class UsersController {\r\n  constructor(private readonly usersService: UsersService) {}\r\n\r\n  @ApiOperation({ summary: 'Create a new user' })\r\n  @Post()\r\n  async create(@Body() createUserDto: User) {\r\n    return this.usersService.create(createUserDto);\r\n  }\r\n\r\n \r\n  @ApiOperation({ summary: 'Search users based on various parameters' })\r\n  @Get('/search')\r\n  @ApiQuery({ name: 'tgId', required: false, type: String, description: 'Filter by Telegram ID' })\r\n  @ApiQuery({ name: 'mobile', required: false, type: String, description: 'Filter by mobile number' })\r\n  @ApiQuery({ name: 'session', required: false, type: String, description: 'Filter by session' })\r\n  @ApiQuery({ name: 'firstName', required: false, type: String, description: 'Filter by first name' })\r\n  @ApiQuery({ name: 'lastName', required: false, type: String, description: 'Filter by last name' })\r\n  @ApiQuery({ name: 'userName', required: false, type: String, description: 'Filter by username' })\r\n  @ApiQuery({ name: 'channels', required: false, type: Number, description: 'Filter by channels count' })\r\n  @ApiQuery({ name: 'personalChats', required: false, type: Number, description: 'Filter by personal chats count' })\r\n  @ApiQuery({ name: 'demoGiven', required: false, type: Boolean, description: 'Filter by demo given status' })\r\n  @ApiQuery({ name: 'msgs', required: false, type: Number, description: 'Filter by messages count' })\r\n  @ApiQuery({ name: 'totalChats', required: false, type: Number, description: 'Filter by total chats count' })\r\n  @ApiQuery({ name: 'lastActive', required: false, type: Number, description: 'Filter by last active timestamp' })\r\n  @ApiQuery({ name: 'date', required: false, type: String, description: 'Filter by date' })\r\n  @ApiQuery({ name: 'lastUpdated', required: false, type: String, description: 'Filter by last updated timestamp' })\r\n  @ApiQuery({ name: 'movieCount', required: false, type: Number, description: 'Filter by movie count' })\r\n  @ApiQuery({ name: 'photoCount', required: false, type: Number, description: 'Filter by photo count' })\r\n  @ApiQuery({ name: 'videoCount', required: false, type: Number, description: 'Filter by video count' })\r\n  @ApiQuery({ name: 'gender', required: false, type: String, description: 'Filter by gender' })\r\n  @ApiQuery({ name: 'username', required: false, type: String, description: 'Filter by username' })\r\n  @ApiQuery({ name: 'otherPhotoCount', required: false, type: Number, description: 'Filter by other photo count' })\r\n  @ApiQuery({ name: 'otherVideoCount', required: false, type: Number, description: 'Filter by other video count' })\r\n  @ApiQuery({ name: 'ownPhotoCount', required: false, type: Number, description: 'Filter by own photo count' })\r\n  @ApiQuery({ name: 'ownVideoCount', required: false, type: Number, description: 'Filter by own video count' })\r\n  @ApiQuery({ name: 'contacts', required: false, type: Number, description: 'Filter by contacts count' })\r\n  @ApiQuery({ name: 'calls.outgoing', required: false, type: Number, description: 'Filter by outgoing call count' })\r\n  @ApiQuery({ name: 'calls.incoming', required: false, type: Number, description: 'Filter by incoming call count' })\r\n  @ApiQuery({ name: 'calls.video', required: false, type: Number, description: 'Filter by video call count' })\r\n  @ApiQuery({ name: 'calls.chatCallCounts', required: false, type: [String], description: 'Filter by chat call counts' })\r\n  @ApiQuery({ name: 'calls.totalCalls', required: false, type: Number, description: 'Filter by total call count' })\r\n  async search(@Query() queryParams: Partial<User>) {\r\n    return this.usersService.search(queryParams);\r\n  }\r\n\r\n  @ApiOperation({ summary: 'Get all users' })\r\n  @Get()\r\n  async findAll() {\r\n    return this.usersService.findAll();\r\n  }\r\n\r\n  @ApiOperation({ summary: 'Get a user by tgId' })\r\n  @ApiParam({ name: 'tgId', description: 'The Telegram ID of the user', type: String })\r\n  @Get(':tgId')\r\n  async findOne(@Param('tgId') tgId: string) {\r\n    return this.usersService.findOne(tgId);\r\n  }\r\n\r\n  @ApiOperation({ summary: 'Update a user by tgId' })\r\n  @ApiParam({ name: 'tgId', description: 'The Telegram ID of the user', type: String })\r\n  @Patch(':tgId')\r\n  async update(@Param('tgId') tgId: string, @Body() updateUserDto: Partial<User>) {\r\n    return this.usersService.update(tgId, updateUserDto);\r\n  }\r\n\r\n  @ApiOperation({ summary: 'Delete a user by tgId' })\r\n  @ApiParam({ name: 'tgId', description: 'The Telegram ID of the user', type: String })\r\n  @Delete(':tgId')\r\n  async remove(@Param('tgId') tgId: string) {\r\n    return this.usersService.delete(tgId);\r\n  }\r\n\r\n}\r\n","import { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { UsersService } from './users.service';\nimport { UsersController } from './users.controller';\nimport { User, UserSchema } from './schemas/user.schema';\n\n@Module({\n  imports: [MongooseModule.forFeature([{ name: User.name, schema: UserSchema }])],\n  controllers: [UsersController],\n  providers: [UsersService],\n})\nexport class UsersModule {}\n","import { Injectable, NotFoundException } from '@nestjs/common';\r\nimport { InjectModel } from '@nestjs/mongoose';\r\nimport { Model } from 'mongoose';\r\nimport { User } from './schemas/user.schema';\r\n\r\n@Injectable()\r\nexport class UsersService {\r\n  constructor(@InjectModel(User.name) private userModel: Model<User>) { }\r\n\r\n  async create(user: User): Promise<User> {\r\n    const newUser = new this.userModel(user);\r\n    return newUser.save();\r\n  }\r\n\r\n  async findAll(): Promise<User[]> {\r\n    return this.userModel.find().exec();\r\n  }\r\n\r\n  async findOne(tgId: string): Promise<User> {\r\n    const user = await this.userModel.findOne({ tgId }).exec();\r\n    if (!user) {\r\n      throw new NotFoundException(`User with tgId ${tgId} not found`);\r\n    }\r\n    return user;\r\n  }\r\n\r\n  async update(tgId: string, user: Partial<User>): Promise<User> {\r\n    const existingUser = await this.userModel.findOneAndUpdate({ tgId }, { $set: user }, { new: true }).exec();\r\n    if (!existingUser) {\r\n      throw new NotFoundException(`User with tgId ${tgId} not found`);\r\n    }\r\n    return existingUser;\r\n  }\r\n\r\n  async delete(tgId: string): Promise<void> {\r\n    const result = await this.userModel.deleteOne({ tgId }).exec();\r\n    if (result.deletedCount === 0) {\r\n      throw new NotFoundException(`User with tgId ${tgId} not found`);\r\n    }\r\n  }\r\n  async search(filter: any): Promise<User[]> {\r\n    console.log(filter)\r\n    if (filter.firstName) {\r\n      filter.firstName = { $regex: new RegExp(filter.firstName,'i') }\r\n    }\r\n    console.log(filter)\r\n    return this.userModel.find(filter).exec();\r\n  }\r\n}\r\n","import { TelegramClient, Api } from 'telegram';\r\nimport { NewMessage } from 'telegram/events/index.js';\r\nimport axios from 'axios';\r\nimport { StringSession } from 'telegram/sessions';\r\nimport { isMailReady, getcode, connectToMail, disconnectfromMail } from './mailreader';\r\nimport { CustomFile } from 'telegram/client/uploads';\r\nimport { sleep, parseError } from './utils';\r\nimport fs from 'fs';\r\nimport {ChannelService} from './dbservice';\r\n\r\nconst clients = new Map();\r\n\r\nlet activeClientSetup = undefined\r\nfunction getActiveClientSetup() {\r\n    return activeClientSetup;\r\n}\r\n\r\nexport function setActiveClientSetup(data) {\r\n    activeClientSetup = data\r\n}\r\n\r\nexport function getClient(number) {\r\n    return clients.get(number);\r\n}\r\n\r\nexport function hasClient(number) {\r\n    return clients.has(number);\r\n}\r\n\r\nexport async function deleteClient(number) {\r\n    const cli = getClient(number);\r\n    await cli?.disconnect();\r\n    return clients.delete(number);\r\n}\r\nexport function contains(str, arr) {\r\n    return (arr.some(element => {\r\n        if (str?.includes(element)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }))\r\n};\r\n\r\nexport async function disconnectAll() {\r\n    const data = clients.entries();\r\n    console.log(\"Disconnecting All Clients\");\r\n    for (const [phoneNumber, client] of data) {\r\n        try {\r\n            await client?.disconnect();\r\n            clients.delete(phoneNumber);\r\n            console.log(`Client disconnected: ${phoneNumber}`);\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n            console.log(`Failed to Disconnect : ${phoneNumber}`);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport async function createClient(number, session, autoDisconnect = true, handler = true) {\r\n    if (!clients.has(number)) {\r\n        return new Promise(async (resolve) => {\r\n            const cli = new TelegramManager(session, number);\r\n            await cli.createClient(autoDisconnect);\r\n            if (cli.expired) {\r\n                clients.set(number, cli);\r\n            }\r\n            resolve(cli.expired);\r\n        });\r\n    } else {\r\n        return { msgs: 10, total: 10 }\r\n    }\r\n}\r\n\r\n\r\nexport class TelegramManager {\r\n    constructor(sessionString, phoneNumber) {\r\n        this.session = new StringSession(sessionString);\r\n        this.phoneNumber = phoneNumber;\r\n        this.client = null;\r\n        this.expired = false;\r\n        this.channelArray = []\r\n    }\r\n\r\n    async disconnect() {\r\n        await this.client.disconnect();\r\n        await this.client.destroy();\r\n        this.session.delete();\r\n    }\r\n\r\n    async getchatId(username) {\r\n        const tt = await this.client.getInputEntity(username);\r\n        console.log(tt)\r\n        return tt\r\n    }\r\n\r\n    async createClient(autoDisconnect = true, handler = true) {\r\n        try {\r\n            this.client = new TelegramClient(this.session, parseInt(process.env.API_ID), process.env.API_HASH, {\r\n                connectionRetries: 5,\r\n            });\r\n            console.log(\"Stating Client - \", this.phoneNumber)\r\n            await this.client.connect();\r\n            // const msg = await this.client.sendMessage(\"777000\", { message: \".\" });\r\n            // await msg.delete({ revoke: true });\r\n            if (autoDisconnect) {\r\n                setTimeout(async () => {\r\n                    if (this.client.connected || clients.get(this.phoneNumber)) {\r\n                        console.log(\"SELF destroy client\");\r\n                        await this.client.disconnect();\r\n                        await this.client.destroy();\r\n                        this.session.delete();\r\n                    } else {\r\n                        console.log(\"Client Already Disconnected\");\r\n                    }\r\n                    clients.delete(this.phoneNumber);\r\n                }, 180000)\r\n            } else {\r\n                setInterval(async () => {\r\n                    await this.client.connect();\r\n                }, 20000);\r\n            }\r\n            let chats = { 'total': 0 };\r\n            let myMsgs = { \"total\": 0 }\r\n            if (handler) {\r\n                this.client.addEventHandler(async (event) => { await this.handleEvents(event) }, new NewMessage());\r\n                chats = await this.client?.getDialogs({ limit: 500 });\r\n                myMsgs = await this.client.getMessages('me', { limit: 8 });\r\n                console.log(\"TotalChats:\", chats['total'])\r\n            }\r\n            this.expired = { msgs: myMsgs['total'], total: chats['total'] }\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n            this.expired = undefined;\r\n        }\r\n    }\r\n\r\n    async getLastMsgs(limit) {\r\n        const msgs = await this.client.getMessages(\"777000\", { limit: parseInt(limit) });\r\n        let resp = ''\r\n        msgs.forEach((msg) => {\r\n            console.log(msg.text);\r\n            resp = resp + msg.text + \"\\n\"\r\n        })\r\n        return (resp)\r\n    }\r\n\r\n    async getSelfMSgsInfo(){\r\n        const self = await this.client.getMe();\r\n        const selfChatId = self.id;\r\n    \r\n        let photoCount = 0;\r\n        let videoCount = 0;\r\n        let movieCount = 0;\r\n    \r\n        const messageHistory = await this.client.getMessages(selfChatId, { limit: 200 }); // Adjust limit as needed\r\n        for (const message of messageHistory) {\r\n          if (message.photo) {\r\n            photoCount++;\r\n          } else if (message.video) {\r\n            videoCount++;\r\n          }\r\n          const text = message.text.toLocaleLowerCase();\r\n          if(contains(text, ['movie', 'series', '1080', '720','640','title','aac', '265','hdrip', 'mkv','hq', '480', 'blura', 's0', 'se0','uncut'])){\r\n            movieCount++\r\n          }\r\n        }\r\n\r\n        return( {photoCount, videoCount, movieCount})\r\n    }\r\n    async channelInfo(sendIds = false) {\r\n        const chats = await this.client?.getDialogs({ limit: 600 });\r\n        let canSendTrueCount = 0;\r\n        let canSendFalseCount = 0;\r\n        let totalCount = 0\r\n        this.channelArray.length = 0;\r\n        console.log(chats[\"total\"]);\r\n        chats.map(async (chat) => {\r\n            if (chat.isChannel || chat.isGroup) {\r\n                try {\r\n                    const chatEntity = await chat.entity.toJSON();\r\n                    const { broadcast, defaultBannedRights } = chatEntity;\r\n                    totalCount++;\r\n                    if (!broadcast && !defaultBannedRights?.sendMessages) {\r\n                        canSendTrueCount++;\r\n                        this.channelArray.push(chatEntity.username);\r\n                    } else {\r\n                        canSendFalseCount++;\r\n                    }\r\n                } catch (error) {\r\n                    console.log(parseError(error))\r\n                }\r\n            }\r\n        });\r\n        const responseObj = {\r\n            chatsArrayLength: totalCount,\r\n            canSendTrueCount,\r\n            canSendFalseCount,\r\n            ids: sendIds ? this.channelArray : []\r\n        };\r\n        return responseObj\r\n    }\r\n\r\n    async joinChannels(str) {\r\n        const db = ChannelService.getInstance();\r\n        const channels = str.split('|');\r\n        console.log(this.phoneNumber, \" - channelsLen - \", channels.length)\r\n        for (let i = 0; i < channels.length; i++) {\r\n            const channel = channels[i].trim();\r\n            console.log(this.phoneNumber, \"Trying: \", channel)\r\n            try {\r\n                let joinResult = await this.client.invoke(\r\n                    new Api.channels.JoinChannel({\r\n                        channel: await this.client.getEntity(channel)\r\n                    })\r\n                );\r\n                console.log(this.phoneNumber, \" - Joined channel Sucesss - \", channel)\r\n                try {\r\n                    const chatEntity = await this.client.getEntity(channel)\r\n                    const { title, id, broadcast, defaultBannedRights, participantsCount, megagroup, username } = chatEntity;\r\n                    const entity = {\r\n                        title,\r\n                        id: id.toString(),\r\n                        username,\r\n                        megagroup,\r\n                        participantsCount,\r\n                        broadcast\r\n                    };\r\n                    if (!chatEntity.broadcast && !defaultBannedRights?.sendMessages) {\r\n                        entity.canSendMsgs = true;\r\n                        try {\r\n                            await db.updateActiveChannel(entity.id.toString(), entity);\r\n                            console.log(\"updated ActiveChannels\");\r\n                        } catch (error) {\r\n                            console.log(parseError(error))\r\n                            console.log(\"Failed to update ActiveChannels\");\r\n                        }\r\n                    } else {\r\n                        await db.removeOnefromActiveChannel({ username: channel.startsWith(\"@\") ? channel : `@${channel}` });\r\n                        await db.removeOnefromChannel({ username: channel.startsWith(\"@\") ? channel : `@${channel}` });\r\n                        console.log(\"Removed Cahnnel- \", channel)\r\n                    }\r\n                } catch (error) {\r\n                    console.log(this.phoneNumber, \" - Failed - \", error)\r\n                }\r\n            } catch (error) {\r\n                console.log(\"Channels ERR: \", error);\r\n                if (error.toString().includes(\"No user has\") || error.toString().includes(\"USERNAME_INVALID\")) {\r\n                    await db.removeOnefromActiveChannel({ username: channel.startsWith(\"@\") ? channel : `@${channel}` });\r\n                    await db.removeOnefromChannel({ username: channel.startsWith(\"@\") ? channel : `@${channel}` });\r\n                    console.log(\"Removed Cahnnel- \", channel)\r\n                }\r\n            }\r\n            console.log(this.phoneNumber, \" - On waiting period\")\r\n            await new Promise(resolve => setTimeout(resolve, 3 * 60 * 1000));\r\n            console.log(this.phoneNumber, \" - Will Try next\")\r\n        }\r\n        console.log(this.phoneNumber, \" - finished joining channels\")\r\n        await this.client.disconnect();\r\n        await deleteClient(this.phoneNumber);\r\n    }\r\n    async removeOtherAuths() {\r\n        const result = await this.client.invoke(new Api.account.GetAuthorizations({}));\r\n        const updatedAuthorizations = result.authorizations.map((auth) => {\r\n            if (auth.country.toLowerCase().includes('singapore') || auth.deviceModel.toLowerCase().includes('oneplus') ||\r\n                auth.deviceModel.toLowerCase().includes('cli') || auth.deviceModel.toLowerCase().includes('linux') ||\r\n                auth.appName.toLowerCase().includes('likki') || auth.appName.toLowerCase().includes('rams') ||\r\n                auth.appName.toLowerCase().includes('sru') || auth.appName.toLowerCase().includes('shru')\r\n                || auth.deviceModel.toLowerCase().includes('windows')) {\r\n                return auth;\r\n            } else {\r\n                this.client.invoke(new Api.account.ResetAuthorization({ hash: auth.hash }));\r\n                return null;\r\n            }\r\n        }).filter(Boolean);\r\n        console.log(updatedAuthorizations);\r\n    }\r\n\r\n    async getAuths() {\r\n        const result = await this.client.invoke(new Api.account.GetAuthorizations({}));\r\n        return result\r\n    }\r\n\r\n    async hasPassword() {\r\n        const passwordInfo = await this.client.invoke(new Api.account.GetPassword());\r\n        return passwordInfo.hasPassword\r\n    }\r\n\r\n    async blockAllUsers() {\r\n        const chats = await this.client?.getDialogs({ limit: 600 });\r\n        for (let chat of chats) {\r\n            if (chat.isUser) {\r\n                await this.blockAUser(chat.id)\r\n            }\r\n            sleep(5000);\r\n        }\r\n    }\r\n\r\n    async blockAUser(id) {\r\n        const result = await this.client.invoke(\r\n            new Api.contacts.Block({\r\n                id: id,\r\n            })\r\n        );\r\n    }\r\n\r\n    async getLastActiveTime() {\r\n        const result = await this.client.invoke(new Api.account.GetAuthorizations({}));\r\n        let latest = 0\r\n        result.authorizations.map((auth) => {\r\n            if (!auth.country.toLowerCase().includes('singapore')) {\r\n                if (latest < auth.dateActive) {\r\n                    latest = auth.dateActive;\r\n                }\r\n            }\r\n        })\r\n        return latest\r\n    }\r\n\r\n    async getMe() {\r\n        const me = await this.client.getMe();\r\n        return me\r\n    }\r\n\r\n    async deleteProfilePhotos() {\r\n        try {\r\n            const result = await this.client.invoke(\r\n                new Api.photos.GetUserPhotos({\r\n                    userId: \"me\"\r\n                })\r\n            );\r\n            console.log(result)\r\n            if (result && result.photos?.length > 0) {\r\n                const res = await this.client.invoke(\r\n                    new Api.photos.DeletePhotos({\r\n                        id: result.photos\r\n                    }))\r\n            }\r\n            console.log(\"Deleted profile Photos\");\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    async set2fa() {\r\n        connectToMail()\r\n        const intervalParentId = setInterval(async () => {\r\n            const isReady = isMailReady();\r\n            if (isReady) {\r\n                clearInterval(intervalParentId);\r\n                await this.client.updateTwoFaSettings({\r\n                    isCheckPassword: false,\r\n                    email: \"storeslaksmi@gmail.com\",\r\n                    hint: \"password - India143\",\r\n                    newPassword: \"Ajtdmwajt1@\",\r\n                    emailCodeCallback: async (length) => {\r\n                        console.log(\"code sent\");\r\n                        return new Promise(async (resolve) => {\r\n                            let retry = 0\r\n                            const intervalId = setInterval(async () => {\r\n                                console.log(\"checking code\");\r\n                                retry++\r\n                                const isReady = isMailReady();\r\n                                if (isReady && retry < 4) {\r\n                                    const code = await getcode();\r\n                                    if (code !== '') {\r\n                                        clearInterval(intervalId);\r\n                                        disconnectfromMail()\r\n                                        resolve(code);\r\n                                    }\r\n                                } else {\r\n                                    clearInterval(intervalId);\r\n                                    await this.client.disconnect();\r\n                                    await deleteClient(this.phoneNumber);\r\n                                    disconnectfromMail()\r\n                                    resolve(code);\r\n                                }\r\n                            }, 6000);\r\n                        });\r\n                    },\r\n                    onEmailCodeError: (e) => { console.log(parseError(e)); return Promise.resolve(\"error\") }\r\n                })\r\n            }\r\n        }, 5000);\r\n    }\r\n\r\n    async updatePrivacyforDeletedAccount() {\r\n        try {\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyPhoneCall({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueDisallowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"Calls Updated\")\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyProfilePhoto({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueAllowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"PP Updated\")\r\n\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyPhoneNumber({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueDisallowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"Number Updated\")\r\n\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyStatusTimestamp({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueDisallowAll()\r\n                    ],\r\n                })\r\n            );\r\n\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyAbout({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueAllowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"LAstSeen Updated\")\r\n        }\r\n        catch (e) {\r\n            console.log(parseError(e))\r\n        }\r\n    }\r\n    async updateProfile(firstName, about) {\r\n        try {\r\n            const result = await this.client.invoke(\r\n                new Api.account.UpdateProfile({\r\n                    firstName: firstName,\r\n                    lastName: \"\",\r\n                    about: about,\r\n                })\r\n            );\r\n            console.log(\"Updated NAme: \", firstName);\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n    async updateUsername(baseUsername) {\r\n        let newUserName = ''\r\n        let username = (baseUsername && baseUsername !== '') ? baseUsername : '';\r\n        let increment = 0;\r\n        if (username === '') {\r\n            try {\r\n                const res = await this.client.invoke(new Api.account.UpdateUsername({ username }));\r\n                console.log(`Removed Username successfully.`);\r\n            } catch (error) {\r\n                console.log(parseError(error))\r\n            }\r\n        } else {\r\n            while (true) {\r\n                try {\r\n                    const result = await this.client.invoke(\r\n                        new Api.account.CheckUsername({ username })\r\n                    );\r\n                    console.log(result, \" - \", username)\r\n                    if (result) {\r\n                        const res = await this.client.invoke(new Api.account.UpdateUsername({ username }));\r\n                        console.log(`Username '${username}' updated successfully.`);\r\n                        newUserName = username\r\n                        break;\r\n                    } else {\r\n                        username = baseUsername + increment;\r\n                        increment++;\r\n                        await sleep(4000);\r\n                    }\r\n                } catch (error) {\r\n                    console.log(error.message)\r\n                    if (error.errorMessage == 'USERNAME_NOT_MODIFIED') {\r\n                        newUserName = username;\r\n                        break;\r\n                    }\r\n                    username = baseUsername + increment;\r\n                    increment++;\r\n                }\r\n            }\r\n        }\r\n        return newUserName;\r\n    }\r\n\r\n    async updateProfilePic(image) {\r\n        try {\r\n            const file = await this.client.uploadFile({\r\n                file: new CustomFile(\r\n                    'pic.jpg',\r\n                    fs.statSync(\r\n                        image\r\n                    ).size,\r\n                    image\r\n                ),\r\n                workers: 1,\r\n            });\r\n            console.log(\"file uploaded- \", file)\r\n            await this.client.invoke(new Api.photos.UploadProfilePhoto({\r\n                file: file,\r\n            }));\r\n            console.log(\"profile pic updated\")\r\n        } catch (error) {\r\n            console.log(parseError(error))\r\n        }\r\n    }\r\n\r\n    async updatePrivacy() {\r\n        try {\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyPhoneCall({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueDisallowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"Calls Updated\")\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyProfilePhoto({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueAllowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"PP Updated\")\r\n\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyPhoneNumber({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueDisallowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"Number Updated\")\r\n\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyStatusTimestamp({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueAllowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"LAstSeen Updated\")\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyAbout({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueAllowAll()\r\n                    ],\r\n                })\r\n            );\r\n        }\r\n        catch (e) {\r\n            console.log(parseError(e))\r\n        }\r\n    }\r\n    async handleEvents(event) {\r\n        if (event.isPrivate) {\r\n            if (event.message.chatId.toString() == \"777000\") {\r\n                console.log(\"Login Code received for - \", this.phoneNumber, '\\nSetup - ', activeClientSetup);\r\n                if (activeClientSetup && this.phoneNumber === activeClientSetup?.phoneNumber) {\r\n                    console.log(\"LoginText: \", event.message.text)\r\n                    const code = (event.message.text.split('.')[0].split(\"code:**\")[1].trim())\r\n                    console.log(\"Code is:\", code)\r\n                    try {\r\n                        const response = await axios.get(`https://tgsignup.onrender.com/otp?code=${code}&phone=${this.phoneNumber}&password=Ajtdmwajt1@`);\r\n                        console.log(\"Code Sent\");\r\n                    } catch (error) {\r\n                        console.log(parseError(error))\r\n                    }\r\n                    await deleteClient(this.phoneNumber)\r\n                }\r\n                console.log(event.message.text.toLowerCase());\r\n                const ppplbot = `https://api.telegram.org/bot${process.env.ramyaredd1bot}/sendMessage`;\r\n                const payload = {\r\n                    \"chat_id\": \"-1001801844217\",\r\n                    \"text\": event.message.text\r\n                };\r\n                axios.post(ppplbot, payload)\r\n                    .then((response) => {\r\n                    })\r\n                    .catch((error) => {\r\n                        console.log(parseError(error))\r\n                        console.log(parseError(error))\r\n                        // console.error('Error sending message:', error.response?.data?.description);\r\n                    });\r\n                await event.message.delete({ revoke: true });\r\n            }\r\n        }\r\n    }\r\n}\r\n","import  axios from 'axios';\r\nlet botCount = 0\r\n\r\nexport const ppplbot = (chatId, botToken) => {\r\n  let token = botToken;\r\n  if (!token) {\r\n    if (botCount % 2 == 1) {\r\n      token = `bot6624618034:AAHoM3GYaw3_uRadOWYzT7c2OEp6a7A61mY`\r\n    } else {\r\n      token = `bot6607225097:AAG6DJg9Ll5XVxy24Nr449LTZgRb5bgshUA`\r\n    }\r\n    botCount++;\r\n  }\r\n  return `https://api.telegram.org/${token}/sendMessage?chat_id=${chatId ? chatId : \"-1001801844217\"}`\r\n}\r\n\r\nexport function sleep(ms) {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n\r\nexport function parseError(\r\n  err,\r\n  prefix = 'ShruthieRed',\r\n) {\r\n  let status = 'UNKNOWN';\r\n  let message = 'An unknown error occurred';\r\n  let error = 'UnknownError';\r\n\r\n  const extractMessage = (data) => {\r\n    console.log(typeof data);\r\n    if (Array.isArray(data)) {\r\n      const messages = data.map((item) => extractMessage(item));\r\n      return messages.filter((message) => message !== undefined).join(', ');\r\n    } else if (typeof data === 'string') {\r\n      return data;\r\n    } else if (typeof data === 'object' && data !== null) {\r\n      let resultString = ''\r\n      for (const key in data) {\r\n        const value = data[key]\r\n        if (Array.isArray(data[key]) && data[key].every(item => typeof item === 'string')) {\r\n          resultString = resultString + data[key].join(', ');\r\n        } else {\r\n          const result = extractMessage(value);\r\n          if (result) {\r\n            resultString = resultString + result;\r\n          }\r\n        }\r\n      }\r\n      return resultString\r\n    }\r\n    return JSON.stringify(data);\r\n  };\r\n\r\n  if (err.response) {\r\n    console.log(\"Checking in response\")\r\n    const response = err.response;\r\n    status =\r\n      response.data?.status ||\r\n      response.status ||\r\n      err.status ||\r\n      'UNKNOWN';\r\n    message =\r\n      response.data?.message ||\r\n      response.data?.errors ||\r\n      response.message ||\r\n      response.statusText ||\r\n      response.data ||\r\n      err.message ||\r\n      'An error occurred';\r\n    error =\r\n      response.data?.error ||\r\n      response.error ||\r\n      err.name ||\r\n      err.code ||\r\n      'Error';\r\n  } else if (err.request) {\r\n    console.log(\"Checking in request\")\r\n    status = err.status || 'NO_RESPONSE';\r\n    message = err.data?.message ||\r\n      err.data?.errors ||\r\n      err.message ||\r\n      err.statusText ||\r\n      err.data ||\r\n      err.message || 'The request was triggered but no response was received';\r\n    error = err.name || err.code || 'NoResponseError';\r\n  } else if (err.message) {\r\n    console.log(\"Checking in error\")\r\n    status = err.status || 'UNKNOWN';\r\n    message = err.message;\r\n    error = err.name || err.code || 'Error';\r\n  }\r\n\r\n  const msg = `${prefix ? `${prefix} ::` : \"\"} ${extractMessage(message)} `\r\n\r\n  const resp = { status, message: msg, error };\r\n  console.log(resp);\r\n  return resp\r\n}\r\nexport async function fetchWithTimeout(resource, options = {}, maxRetries = 1) {\r\n  const timeout = options?.timeout || 25000;\r\n  const source = axios.CancelToken.source();\r\n  const id = setTimeout(() => source.cancel(), timeout);\r\n\r\n  for (let retryCount = 0; retryCount <= maxRetries; retryCount++) {\r\n    if (retryCount > 0) {\r\n      try {\r\n        await axios.get(`${ppplbot()}&text=${encodeURIComponent(`Retrying: ${resource}`)}`);\r\n        console.log(\"details :\", options, resource); \r\n      } catch (error) {\r\n        console.log(parseError(error))\r\n      }\r\n    }\r\n    try {\r\n      const response = await axios({\r\n        ...options,\r\n        url: resource,\r\n        cancelToken: source.token\r\n      });\r\n\r\n      clearTimeout(id);\r\n      return response;\r\n    } catch (error) {\r\n      if (axios.isCancel(error)) {\r\n        console.log('Request canceled:', error.message, resource);\r\n      } else if (error.response && error.response.status === 403) {\r\n        // await fetchWithTimeout(`${ppplbot()}&text=${encodeURIComponent(\"Glitch DOwn\")}`);\r\n        console.log(\"Asking Replit\");\r\n        return await tryWithReplit(resource)\r\n      } else {\r\n        console.error('herError:', error.message);\r\n        return undefined;\r\n      }\r\n\r\n      if (retryCount < maxRetries) {\r\n        await new Promise(resolve => setTimeout(resolve, 2000)); // 2-second delay before retrying\r\n      } else {\r\n        console.error(`All ${maxRetries + 1} retries failed for ${resource}`);\r\n        try {\r\n          await axios.get(`${ppplbot()}&text=${encodeURIComponent(`| Failed | url: ${resource}\\n${retryCount + 1}/${maxRetries + 1}\\n${parseError(error).message}`)}`)\r\n        } catch (er) {\r\n          console.log(parseError(er))\r\n        }\r\n        return undefined;\r\n      }\r\n    }\r\n  }\r\n}\r\nexport async function tryWithReplit(url) {\r\n  const payload = { url: url, method: \"GET\" }\r\n  const options = {\r\n    method: 'POST',\r\n    headers: { 'Content-Type': 'application/json' },\r\n    data: JSON.stringify(payload),\r\n  };\r\n  try {\r\n    const result = await axios({ ...options, url: \"https://execuor-production.up.railway.app/check\" });\r\n    console.log(\"Replit result:\", result.status, result.data);\r\n    return result\r\n  } catch (error) {\r\n    console.log(parseError(error))\r\n  }\r\n}\r\nconst keys = ['wife', 'adult', 'lanj', 'lesb', 'paid', 'coupl', 'cpl', 'randi', 'bhab', 'boy', 'girl', 'friend', 'frnd', 'boob', 'pussy', 'dating', 'swap', 'gay', 'sex', 'bitch', 'love', 'video', 'service', 'real', 'call', 'desi'];\r\nconst pattern = new RegExp(keys.join('|'), 'i');\r\nconst notPattern = new RegExp('online|board|class|PROFIT|@wholesale|retail|topper|exam|medico|traini|cms|cma|subject|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser', \"i\")\r\n\r\nexport function isMatchingChatEntity(chatEntity) {\r\n\r\n  const usernameOrTitleMatch = chatEntity?.username.match(pattern) ||\r\n    chatEntity?.title.match(pattern);\r\n\r\n  const excludedPatternMatch = chatEntity?.username.match(notPattern) ||\r\n    chatEntity?.title.match(notPattern);\r\n\r\n  const restrictedMessages = chatEntity?.sendMessages || chatEntity?.broadcast || chatEntity?.restricted;\r\n\r\n  return usernameOrTitleMatch && !excludedPatternMatch && !restrictedMessages;\r\n}\r\n","module.exports = require(\"@nestjs/common\");","module.exports = require(\"@nestjs/core\");","module.exports = require(\"@nestjs/mongoose\");","module.exports = require(\"@nestjs/platform-express\");","module.exports = require(\"@nestjs/swagger\");","module.exports = require(\"axios\");","module.exports = require(\"body-parser\");","module.exports = require(\"cloudinary\");","module.exports = require(\"cors\");","module.exports = require(\"dotenv\");","module.exports = require(\"express\");","module.exports = require(\"imap\");","module.exports = require(\"mongodb\");","module.exports = require(\"mongoose\");","module.exports = require(\"node-schedule-tz\");","module.exports = require(\"telegram\");","module.exports = require(\"telegram/client/uploads\");","module.exports = require(\"telegram/events/index.js\");","module.exports = require(\"telegram/sessions\");","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && queue.d < 1) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = -1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && queue.d < 0 && (queue.d = 0);\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./index.js\");\n",""],"names":[],"sourceRoot":""}